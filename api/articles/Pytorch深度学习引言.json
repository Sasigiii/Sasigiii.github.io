{"title":"Pytorch深度学习引言","uid":"33f1db3ba8f93ed1537346a0403c58d0","slug":"Pytorch深度学习引言","date":"2023-11-07T12:41:10.000Z","updated":"2023-11-08T13:22:57.398Z","comments":true,"path":"api/articles/Pytorch深度学习引言.json","keywords":null,"cover":[],"content":"<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>参数（parameter）可以被看做旋钮，旋钮的转动可以调整程序的行为。即可以通过改变参数来调节模型的行为。</p>\n<h2 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h2><p>任一调整参数后的程序被称为模型（model）。通过操作参数而生成的所有不同程序(输入-输出映射)的集合被称为“模型族”。使用数据集（dataset）来选择参数的元程序被称为学习算法（learning algorithm）。</p>\n<p>在开始用机器学习算法解决问题之前，我们必须精确地定义问题，来确定输入(input)和输出(output)的性质，并选择合适的模型族。比如模型接收一段音频作为输入，然后再是或否中生成一个选择来作为输出。如果一切都顺利，经过一番训练，模型对于 “片段是否包含唤醒词”的预测通常是正确的。</p>\n<h2 id=\"机器学习\"><a href=\"#机器学习\" class=\"headerlink\" title=\"机器学习\"></a>机器学习</h2><p>在机器学习中，<em>学习</em>（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据<em>训练</em>（train）模型。 如 <a href=\"https://zh.d2l.ai/chapter_introduction/index.html#fig-ml-loop\">图1.1.2</a>所示，训练过程通常包含如下步骤：</p>\n<ol>\n<li>从一个随机初始化参数的模型开始，这个模型基本没有“智能”；</li>\n<li>获取一些数据样本（例如，音频片段以及对应的是或否标签）；</li>\n<li>调整参数，使模型在这些样本中表现得更好；</li>\n<li>重复第（2）步和第（3）步，直到模型在任务中的表现令人满意。</li>\n</ol>\n<p><img src=\"https://zh.d2l.ai/_images/ml-loop.svg\" alt=\"../_images/ml-loop.svg\"></p>\n<p>​                                                             图1.1.2* 一个典型的训练过程</p>\n<p>总而言之，我们没有编写唤醒词识别器，而是编写了一个“学习”程序。 如果我们用一个巨大的带标签的数据集，它很可能可以“学习”识别唤醒词。 这种“通过用数据集来确定程序行为”的方法可以被看作<em>用数据编程</em>（programming with data）。</p>\n<h2 id=\"机器学习中的关键组件\"><a href=\"#机器学习中的关键组件\" class=\"headerlink\" title=\"机器学习中的关键组件\"></a>机器学习中的关键组件</h2><p>首先介绍一些核心组件。无论什么类型的机器学习问题，都会遇到这些组件：</p>\n<ol>\n<li>可以用来学习的<em>数据</em>（data）；</li>\n<li>如何转换数据的<em>模型</em>（model）；</li>\n<li>一个<em>目标函数</em>（objective function），用来量化模型的有效性；</li>\n<li>调整模型参数以优化目标函数的<em>算法</em>（algorithm）。</li>\n</ol>\n<h3 id=\"数据\"><a href=\"#数据\" class=\"headerlink\" title=\"数据\"></a>数据</h3><p>每个数据集由一个个<em>样本</em>（example, sample）组成，大多时候，它们遵循<strong>独立同分布</strong>(independently and identically distributed, i.i.d.)。 样本有时也叫做<strong>数据点</strong>（data point）或者<em>数据实例</em>（data instance），通常每个样本由一组称为<em>特征</em>（features，或<em>协变量</em>（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 在上面的监督学习问题中，要预测的是一个特殊的属性，它被称为<em>标签</em>（label，或<em>目标</em>（target））。</p>\n<p>当处理图像数据时，每一张单独的照片即为一个样本，它的特征由每个像素数值的有序列表表示。 比如，200×200彩色照片由200×200×3&#x3D;120000个数值组成，其中的“3”对应于每个空间位置的红、绿、蓝通道的强度。 再比如，对于一组医疗数据，给定一组标准的特征（如年龄、生命体征和诊断），此数据可以用来尝试预测患者是否会存活。</p>\n<p>当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的<em>维数</em>（dimensionality）。 固定长度的特征向量是一个方便的属性，它可以用来量化学习大量样本。</p>\n<p>然而，并不是所有的数据都可以用“固定长度”的向量表示。例如淘宝上的购物评价，有的很简短，有的又是长篇大论。与传统的机器学习相比，深度学习的一个主要优势是可以处理不同长度的数据。</p>\n<h3 id=\"模型-1\"><a href=\"#模型-1\" class=\"headerlink\" title=\"模型\"></a>模型</h3><p>深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为<em>深度学习</em>（deep learning）。</p>\n<h3 id=\"目标函数\"><a href=\"#目标函数\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h3><p>在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，这被称之为<em><strong>目标函数</strong></em>（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为<em>损失函数</em>（loss function，或cost function）。 但这只是一个惯例，我们也可以取一个新的函数，优化到它的最高点。 这两个函数本质上是相同的，只是翻转一下符号。</p>\n<h3 id=\"目标函数-1\"><a href=\"#目标函数-1\" class=\"headerlink\" title=\"目标函数\"></a>目标函数</h3><p>当任务在试图预测数值时，最常见的损失函数是<strong><em>平方误差</em>（squared error）</strong>，即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是<strong>最小化错误率</strong>，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化<em>替代目标</em>。</p>\n<p>通常，损失函数是根据模型参数定义的，并取决于数据集。 <strong>在一个数据集上，我们可以通过最小化总损失来学习模型参数的最佳值。</strong> <strong>该数据集由一些为训练而收集的样本组成，称为<em>训练数据集</em>（training dataset，或称为<em>训练集</em>（training set））</strong>。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的性能，这里的“<strong>新数据集”通常称为<em>测试数据集</em>（test dataset，或称为<em>测试集</em>（test set））。</strong></p>\n<p>综上所述，可用数据集通常可以分成两部分：<strong>训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型</strong>。 然后我们观察模型在这两部分数据集的性能。 “一个模型在训练数据集上的性能”可以被想象成“一个学生在模拟考试中的分数”。 这个分数用来为一些真正的期末考试做参考，即使成绩令人鼓舞，也不能保证期末考试成功。 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，这个模型被称为<em>过拟合</em>（overfitting）的。 就像在现实生活中，尽管模拟考试考得很好，真正的考试不一定百发百中。</p>\n<h3 id=\"优化算法\"><a href=\"#优化算法\" class=\"headerlink\" title=\"优化算法\"></a>优化算法</h3><p>当我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法–<strong><em>梯度下降</em>（gradient descent）</strong>。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。</p>\n<h2 id=\"各种机器学习问题\"><a href=\"#各种机器学习问题\" class=\"headerlink\" title=\"各种机器学习问题\"></a>各种机器学习问题</h2><h3 id=\"监督学习\"><a href=\"#监督学习\" class=\"headerlink\" title=\"监督学习\"></a>监督学习</h3><p><em>监督学习</em>（supervised learning）擅长在“<strong>给定输入特征</strong>”的情况下预测标签。 每个“特征-标签”对都称为一个<em>样本</em>（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签（即预测）。</p>\n<p>举一个具体的例子： 假设我们需要预测患者的心脏病是否会发作，那么观察结果“<strong>心脏病发作”或“心脏病没有发作”将是样本的标签。</strong> <strong>输入特征可能是生命体征，如心率、舒张压和收缩压等。</strong></p>\n<p>在一定程度上，许多重要的任务可以清晰地描述为，在给定一组特定的可用数据的情况下，估计未知事物的概率。</p>\n<p>监督学习的学习过程一般可以分为三大步骤：</p>\n<ol>\n<li>从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；</li>\n<li>选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；</li>\n<li>将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。</li>\n</ol>\n<p>整个监督学习过程如 <a href=\"https://zh.d2l.ai/chapter_introduction/index.html#fig-supervised-learning\">图1.3.1</a> 所示。</p>\n<p><img src=\"https://zh.d2l.ai/_images/supervised-learning.svg\" alt=\"../_images/supervised-learning.svg\"></p>\n<p>​                                                                   <em>图1.3.1</em> 监督学习</p>\n<p>综上所述，即使使用简单的描述给定输入特征的预测标签，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量。 例如，我们使用不同的模型来处理“任意长度的序列”或“固定长度的序列”。</p>\n<h4 id=\"回归\"><a href=\"#回归\" class=\"headerlink\" title=\"回归\"></a>回归</h4><p><strong><em>回归</em>（regression）是最简单的监督学习任务之一。</strong> 假设有一组房屋销售数据表格，其中每行对应一个房子，每列对应一个相关的属性，例如房屋的面积、卧室的数量、浴室的数量以及到镇中心的步行距离，等等。 每一行的属性构成了一个房子样本的特征向量。 如果一个人住在纽约或旧金山，那么他家的特征向量（房屋面积，卧室数量，浴室数量，步行距离）可能类似于：[600,1,1,60]。 如果一个人住在匹兹堡，这个特征向量可能更接近[3000,4,3,10]…… 当人们在市场上寻找新房子时，可能需要估计一栋房子的公平市场价值。 为什么这个任务可以归类为回归问题呢？本质上是<strong>输出决定的</strong>。 <strong>销售价格（即标签）是一个数值。 当标签取任意数值时，我们称之为<em>回归</em>问题，此时的目标是生成一个模型，使它的预测非常接近实际标签值。</strong></p>\n<p>总而言之，判断回归问题的一个很好的经验法则是，<strong>任何有关“有多少”的问题很可能就是回归问题。</strong></p>\n<h4 id=\"分类\"><a href=\"#分类\" class=\"headerlink\" title=\"分类\"></a>分类</h4><p>虽然回归模型可以很好地解决“有多少”的问题，但是很多问题并非如此。 例如，一家银行希望在其移动应用程序中添加支票扫描功能。 具体地说，这款应用程序能够自动理解从图像中看到的文本，并将手写字符映射到对应的已知字符之上。 这种“哪一个”的问题叫做<strong><em>分类</em>（classification）问题。</strong></p>\n<p> <em>*<em>分类</em>问题希望模型能够预测样本属于哪个*类别</em>（category，正式称为<em>类</em>（class））。<strong>例如，手写数字可能有10类，标签被设置为数字0～9。 最简单的分类问题是只有两类，这被称之为</strong><em>二项分类</em><strong>（binomial classification）。 例如，数据集可能由动物图像组成，标签可能是猫狗{猫,狗}两类。 当有两个以上的类别时，我们把这个问题称为</strong><em>多项分类</em><strong>（multiclass classification）问题。常见的例子包括手写字符识别{0,1,2,…9,a,b,c,…}。</strong>与解决回归问题不同，分类问题的常见损失函数被称为<em>交叉熵</em>（cross-entropy）。**</p>\n<p><strong>回归是训练一个回归函数来输出一个数值； 分类是训练一个分类器来输出预测的类别。</strong></p>\n<h4 id=\"标记问题\"><a href=\"#标记问题\" class=\"headerlink\" title=\"标记问题\"></a>标记问题</h4><p><strong>学习预测不相互排斥的类别的问题称为<em>多标签分类</em>（multi-label classification）。</strong></p>\n","feature":true,"text":"参数参数（parameter）可以被看做旋钮，旋钮的转动可以调整程序的行为。即可以通过改变参数来调节模型的行为。 模型任一调整参数后的程序被称为模型（model...","permalink":"/post/Pytorch深度学习引言","photos":[],"count_time":{"symbolsCount":"4.3k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"Pytorch深度学习","slug":"Pytorch深度学习","count":1,"path":"api/tags/Pytorch深度学习.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">参数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">模型</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0\"><span class=\"toc-text\">机器学习</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6\"><span class=\"toc-text\">机器学习中的关键组件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE\"><span class=\"toc-text\">数据</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9E%8B-1\"><span class=\"toc-text\">模型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">目标函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0-1\"><span class=\"toc-text\">目标函数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">优化算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%84%E7%A7%8D%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">各种机器学习问题</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0\"><span class=\"toc-text\">监督学习</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%9B%9E%E5%BD%92\"><span class=\"toc-text\">回归</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB\"><span class=\"toc-text\">分类</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%87%E8%AE%B0%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">标记问题</span></a></li></ol></li></ol></li></ol>","author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Socket基础","uid":"514d1808d25e64b8077292b0b40d87f8","slug":"Socket学习记录","date":"2023-11-07T12:41:10.000Z","updated":"2024-12-08T14:02:09.078Z","comments":true,"path":"api/articles/Socket学习记录.json","keywords":null,"cover":[],"text":"Socket基础客户端：1. Socket的初始化与连接操作12345678910private Socket _socket; void Start()&#1...","permalink":"/post/Socket学习记录","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Unity网络开发","slug":"Unity网络开发","count":2,"path":"api/tags/Unity网络开发.json"}],"author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Unity中寻路方法的客户端和服务端使用","uid":"6b1fbd4218c627ebe69e7d6fff287d2a","slug":"Unity中寻路方法的客户端和服务端使用","date":"2023-11-07T12:41:10.000Z","updated":"2024-12-08T14:03:44.440Z","comments":true,"path":"api/articles/Unity中寻路方法的客户端和服务端使用.json","keywords":null,"cover":[],"text":"AStar寻路:前言：在Unity3D中有一个内置的寻路解决方案：NavMeshes和NavMesh Agents。NavMeshes被用在可以行走的几何图形表...","permalink":"/post/Unity中寻路方法的客户端和服务端使用","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Unity开发","slug":"Unity开发","count":2,"path":"api/tags/Unity开发.json"}],"author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}}}}