{"title":"Unity中寻路方法的客户端和服务端使用","uid":"6b1fbd4218c627ebe69e7d6fff287d2a","slug":"Unity中寻路方法的客户端和服务端使用","date":"2023-11-07T12:41:10.000Z","updated":"2024-12-08T14:03:44.440Z","comments":true,"path":"api/articles/Unity中寻路方法的客户端和服务端使用.json","keywords":null,"cover":[],"content":"<h1 id=\"AStar寻路\"><a href=\"#AStar寻路\" class=\"headerlink\" title=\"AStar寻路:\"></a>AStar寻路:</h1><h3 id=\"前言：\"><a href=\"#前言：\" class=\"headerlink\" title=\"前言：\"></a>前言：</h3><p>在Unity3D中有一个内置的寻路解决方案：NavMeshes和NavMesh Agents。NavMeshes被用在可以行走的几何图形表面上，NavMesh Agents则挂载到游戏角色和其他需要导航的角色上。Navmeshes和NavMesh Agents一起工作来提供高效的寻路操作，有趣的是这个三维寻路解决方案的背后算法正是AStar。遗憾的是，在Unity2D中，并没有内置寻路的解决方案，我们必须手写相关的逻辑。</p>\n<h3 id=\"AStar的工作原理：\"><a href=\"#AStar的工作原理：\" class=\"headerlink\" title=\"AStar的工作原理：\"></a>AStar的工作原理：</h3><p>使用AStar的前提是：地图需要有一个网状结构。无论是用四叉树或八叉树做空间划分还是游戏地图本身就由Tilemap搭建。</p>\n<p>每个网格方块或节点根据从 start 节点到finish 节点都有一个“总成本”。每一个被评估过的节点都有一条回到start节点的路径，而这一路径是通过记录每个节点的父节点。因此通过记录每个节点的父节点我们可以得到一条回溯到起点的路径。</p>\n<p>AStar算法计算了几种成本：H成本，G成本和F成本。</p>\n<p><strong>G成本：</strong>节点的G成本是指从起始节点到当前节点的路径总距离。值得注意的是，如果算法找到通往该节点的更短路径，节点的G成本可以被“改进”。</p>\n<p><strong>H成本:</strong>  节点的H成本是指到终点的最小距离的一种简单计算。例如，如果方格之间的水平距离为10单位，而终点距离当前方格有3个水平方格，那么H成本将是30。需要注意的是，这只是最小距离，如果途中有障碍物，这条路径可能无法通行。对于一个节点而言，H成本是不会改变的。</p>\n<p><strong>F成本：</strong> 节点的F成本是指节点的总成本，即是G成本和H成本的总和。算法通过评估节点，并选择从起点到终点具有最低FCost的路径来确定最短路径。</p>\n<p>该算法维护了“Open列表”和“Close列表”。从起始方格开始，算法将其周围所有方格添加到开放列表中。然后，从开放列表中选择F成本最低的方格，将其添加到关闭列表，并对其所有邻居重复此评估过程。此过程持续进行，直到到达目标节点并找到最短路径为止。</p>\n<p>值得考虑的是，只需要考虑网格中方格之间的距离(欧几里得距离)：</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208180852004.png\" alt=\"image-20241208180852004\"></p>\n<p>现在我们已经大概了解了AStar的工作原理，接下来我们来看一段伪代码深入理解一下：</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208181127974.png\" alt=\"image-20241208181127974\"></p>\n<p>首先我们创建一个Open表（存放将要进行评估的节点）和一个Close表（存放已经评估过的节点）。设置Start（起始节点），和Target（目标节点）。</p>\n<p>在算法一开始，我们将Start添加进Open表，在一个While循环（条件为“Open表里还有节点”）里，检索F成本最小的节点作为Current Node。<strong>如果正好有两个F成本一样小的节点，我们就选择H成本较小的那一个。</strong>在While循环开始时，我们将Start设置为Current Node。如果Current Node为Target我们就找到了路径，可以跳出循环，否则我们就将Current Node从Open表移到Close表中。对于Current Node我们会进入另一个循环，这个循环会检查Current Node的8个邻居节点，如果一个邻居节点是一个障碍物或者在Close表里，我们就跳过这个节点，对于每一个没被跳过的邻居节点，我们会计算它的F成本。首先我们计算它的G成本：从Start到Current Node的路径，这个G成本是基于当前节点的父节点回溯回Start的路径，因此对于任意给定节点，取决于所采用的路径，它有不同的G成本，当我们评估不同的路径时节点的G成本可能上升，也可能下降。如果它下降了，那么它会成为一个更好的候选路径。计算H成本：当前节点到Target的最小距离。对于一个特定的结点，H成本不会改变，因为它始终是到Target的最小距离。计算F成本：G成本+H成本。 因此，如果我们目前正在评估的邻居节点，如果<strong>邻居节点不在开放列表中，或它虽然在开放列表中，但重新计算的F成本更低</strong>，那么我们要保存这个节点的G成本，H成本和F成本，并且我们还要将这个邻居节点的父节点设置为Current Node。如果这个邻居节点不在Open表里，那么我们就将它添加进Open表。 最后我们就能得到一个能回溯到Start的最短路径。</p>\n<p>第一次循环：</p>\n<p>左上角为G成本：当前节点到Start的距离。右下角为H成本：当前节点到Finish的最短距离。中间为F成本：G成本+H成本。</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\Snipaste_2024-12-08_20-40-23.png\" alt=\"Snipaste_2024-12-08_20-40-23\"></p>\n<p>第二次循环：由于F成本为50的节点F成本最小，因此将其设置为Current Node，并添加进Close表（变为红色）。计算其邻居节点的三个成本。将其邻居节点全部加入Open表，再次选出其中F成本最小的节点作为Current Node。</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208204508977.png\" alt=\"image-20241208204508977\"></p>\n<p>第三次循环：值得注意的是，我们评估邻居节点不仅仅是那些被添加到Open表里的新节点，同时也包括那些不在Close表里的邻居节点。</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208204834412.png\" alt=\"image-20241208204834412\"></p>\n<p>第四次循环：一般在我们逐渐靠近终点的时候，对于F成本最低的节点来说，它的G成本会逐渐增加而H成本会逐渐减少（越来越靠近终点）。</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208210045452.png\" alt=\"image-20241208210045452\"></p>\n<p>对于有障碍物的情况来说：图二中F成本为44的节点将被选中，同时F成本为66的邻居节点的G成本将得到更新。图三中有两个节点F成本一致，我们要选择H成本较小的那个。最后通过父节点的关系回溯找到最短路径。</p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208210416015.png\" alt=\"image-20241208210416015\"><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208210956834.png\" alt=\"image-20241208210956834\" style=\"zoom:80%;\" /><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208211308575.png\" alt=\"image-20241208211308575\"></p>\n<p><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208211738001.png\" alt=\"image-20241208211738001\"><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208211820360.png\" alt=\"image-20241208211820360\"><img src=\"C:\\Users\\jay\\blog\\source\\images\\image-20241208212127811.png\" alt=\"image-20241208212127811\"></p>\n<p>对于Open表和Close表的数据结构的选择：<br>Open表：我们将使用C#中的<code>List&lt;T&gt;</code> ，因为我们需要对集合进行排序从而找出F成本最小的那个节点。</p>\n<p>Close表：我们将使用 C# 的泛型集合 <code>HashSet&lt;T&gt;</code>。其中的 <code>T</code> 表示网格方格节点。Close表不需要进行排序，只需检查某个节点是否已经存在于Close表中。<code>HashSet</code> 的 <code>Contains</code> 方法可以完成此操作，并且速度非常快，因为它不需要逐一遍历每个元素，而是通过计算的哈希值直接进行检查。</p>\n","text":"AStar寻路:前言：在Unity3D中有一个内置的寻路解决方案：NavMeshes和NavMesh Agents。NavMeshes被用在可以行走的几何图形表...","permalink":"/post/Unity中寻路方法的客户端和服务端使用","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[],"tags":[{"name":"Unity开发","slug":"Unity开发","count":2,"path":"api/tags/Unity开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AStar%E5%AF%BB%E8%B7%AF\"><span class=\"toc-text\">AStar寻路:</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80%EF%BC%9A\"><span class=\"toc-text\">前言：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#AStar%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">AStar的工作原理：</span></a></li></ol></li></ol></li></ol>","author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"前缀和","uid":"7e125c2fcf5388ca1ef0a457d9c6ee91","slug":"前缀和","date":"2023-11-07T12:41:10.000Z","updated":"2024-12-08T18:10:10.232Z","comments":true,"path":"api/articles/前缀和.json","keywords":null,"cover":null,"text":"前缀和一维前缀和1.定义 对于一维前缀和来说，前缀和是这个数组的某个下标之前的（包括当前下标对应的元素）所有元素之和。 声明一个数组 a[]。 数组 a[]的前...","permalink":"/post/前缀和","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"算法学习","slug":"算法学习","count":1,"path":"api/tags/算法学习.json"}],"author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}}},"next_post":{"title":"Unity网络开发基础","uid":"48226afb8ff83ee8121572321054a22a","slug":"Unity网络开发基础","date":"2023-11-07T12:41:10.000Z","updated":"2024-12-08T14:02:42.332Z","comments":true,"path":"api/articles/Unity网络开发基础.json","keywords":null,"cover":null,"text":"网络基本概念 网络：由若干设备和连接这些设备的链路构成，设备间可以相互通信。 局域网：指某一个小区域内由多台设备互联成的计算机组。 以太网：网络连接的一种规则，...","permalink":"/post/Unity网络开发基础","photos":[],"count_time":{"symbolsCount":480,"symbolsTime":"1 mins."},"categories":[],"tags":[{"name":"Unity网络开发","slug":"Unity网络开发","count":2,"path":"api/tags/Unity网络开发.json"}],"author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}}}}