{"title":"骨骼动画与IK","uid":"12b449f4e20ce22d5fbbca66571d4052","slug":"骨骼动画与IK","date":"2023-12-20T09:26:43.000Z","updated":"2024-12-08T09:28:04.494Z","comments":true,"path":"api/articles/骨骼动画与IK.json","keywords":null,"cover":[],"content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本次分享主要介绍骨骼动画与IK，内容包含骨骼动画简介，正向动力学FK，2D 骨骼动画实践，逆向动力学IK，Limb Solver、CCD Solver、FABRIK Solver，2D IK动画实践 。</p>\n<h1 id=\"骨骼动画简介\"><a href=\"#骨骼动画简介\" class=\"headerlink\" title=\"骨骼动画简介\"></a>骨骼动画简介</h1><p><strong>骨骼动画</strong>（Skeletal Animation &#x2F; Rigging）是一种由“骨骼”来控制物体外形的技术。所谓“骨骼”，其实就是一组相互连接的，有层级的结构。这就像人体的骨骼决定了人体的外形（肌肉、皮肤）一样。</p>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=YWM4MzMyM2RjNDI1MDdiYmY1ZjRhMWQ5YjY1YmUyODVfU3pXU2Q3U2ppbGV2RXd6QWtZcUw5MGpJNTFaYm5Xd0NfVG9rZW46WGpQMWJ2SVplb2hoa0p4MklFNWNiVkhJbnRnXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>可以看到每一根骨骼由一个<strong>方向</strong>和一个<strong>长度</strong>组成。骨骼的头部由圆点表示，而尾部由尖端表示。 </p>\n<p>骨骼的层级结构是很清晰的：一根骨骼A的头部与另一根B的尾部相连则代表A是B的“孩子”，即A的位置与旋转继承自B。</p>\n<h1 id=\"骨骼动画-帧动画\"><a href=\"#骨骼动画-帧动画\" class=\"headerlink\" title=\"骨骼动画 &amp; 帧动画\"></a><strong>骨骼动画 &amp; 帧动画</strong></h1><p>在2D开发的情况中，动画主要分为两种：<strong>骨骼动画</strong>与<strong>帧动画</strong>。其中帧动画指的是<strong>在一段时间内每k帧替换一张图片</strong>，使得物体看起来正在动一样。比如所有手绘的动画作品都是帧动画。 </p>\n<p>帧动画的优点是每一帧我们都可以单独定制，所以它<strong>极其可控</strong>；而它的缺点是<strong>占用空间较大</strong>（因为每一张图片要单独存储，如果我们要一个30帧的动画，每秒钟就要30张图片）且<strong>帧率有限</strong>（我们无法在两个关键帧之间插值）。</p>\n<p>而骨骼动画实质上是一种程序化动画。它最大的优点是<strong>实时性</strong>：这意味着它的帧率由游戏帧率决定，且我们可以实时地修改、控制它。其次，它的<strong>占用空间也会小很多</strong>（因为我们只需要记录各个关键帧上骨骼的数据就可以了，这比图片小很多）。 </p>\n<h1 id=\"FK-IK\"><a href=\"#FK-IK\" class=\"headerlink\" title=\"FK &amp; IK\"></a><strong>FK &amp; IK</strong></h1><p>一般来说骨骼动画可以被分为两个类型：<strong>正向动力学</strong>（FK）与<strong>逆向动力学</strong>（IK）。简单来说，FK是一个已知过程再推导处结果的方法，而IK则相反：它是一个通过结果逆向推导出过程的方法。</p>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=YzI1YWE2NmUyNWY1ZmJlZTJiNWEzNDlmODYwNDBhNGFfYzFYYjYxOHN4WnJQRGp1VXg4aUpUWkRWcHJycjR5YjJfVG9rZW46R3NrRmJRQzUxbzJ1Nkd4MjROVmN3SGVNblJnXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>FK可以帮助我们通过L1 – L4（q1 – q4）四个关节的位置与旋转来计算出上方机械臂末端的位置与旋转。</p>\n<p>IK则可以通过机械臂末端的位置与旋转推导出L1 – L4 （q1 – q4）的形态。</p>\n<p>IK明显比FK要复杂很多，IK由起点和终点的位置与旋转进行推导，得出的过程有多种。我们怎么才能得到正确的走法呢？</p>\n<p>我们先从FK入手，方便更好的理解IK的算法。</p>\n<h1 id=\"正向动力学FK（知道过程推导结果）\"><a href=\"#正向动力学FK（知道过程推导结果）\" class=\"headerlink\" title=\"正向动力学FK（知道过程推导结果）\"></a>正向动力学FK（知道过程推导结果）</h1><p>FK相较于IK来说要简单许多。它也更符合我们对骨骼动画的初步认知。</p>\n<p>在一个FK系统中，有这些重要的概念： </p>\n<ol>\n<li>Joint（关节）：这是骨骼的头部，用来控制<strong>旋转，</strong> 就像是胳膊肘和手腕。</li>\n<li>Links（连接）：这是骨骼的尾部，用来控制<strong>长度</strong>与和其它骨骼的<strong>连接，</strong>这些连接可以用来表示和其他骨骼的继承关系。 </li>\n<li>End-Effector（末端器）：这是整条骨骼的<strong>尾部</strong>。 </li>\n<li>Kinematic Chain（动力学链）：这代表了<strong>一整条彼此相连的骨骼</strong>。</li>\n</ol>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTUyNTdmNTZiNzQwMDUwZDBmZDJjMjgwYjNlMDY5M2NfNUFNV1hxTVBGZUxYaHJxTldnYkU2MXMyVk9KRmpGNkhfVG9rZW46TllrZGIzYzFxbzNvWjZ4a2M3cGNNZWlabktkXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>由以上概念可以知道FK的本质是确定末端器的状态，但其实每一个骨骼都可以被看作一个末端器（为什么？）；于是我们可以通过FK确定整条骨骼具体的形态。</p>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2MxZDBhYjZiMTU4Y2FkZTM2NDBjNjQxODliNzFiNzJfSnJRYmQ1WmtScG5yNnFlWmIzbWVscnpHODRCejVoOE5fVG9rZW46UDVWQ2JNeUoxb1hlQWZ4SW5NZmMyUFM4bkZnXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>因此我们可以由第一个末端器推出第二个末端器的位置，再由第二个末端器的位置推出第三个末端器的位置，以此类推。</p>\n<p>FK就是从头到尾递推出整根骨骼的形态，最后我们再把整个骨骼的形态应用到物体上。</p>\n<h1 id=\"计算FK末端器的状态\"><a href=\"#计算FK末端器的状态\" class=\"headerlink\" title=\"计算FK末端器的状态\"></a>计算FK末端器的状态</h1><p>对于一根骨骼b1，想要计算它的状态我们只需要知道它的“根骨骼”b0的状态即可。 </p>\n<p><strong>b1的头部位置</strong> &#x3D; b0的尾部位置 &#x3D; b0的头部位置+b0的方向*b0的长度 </p>\n<p><strong>b1的尾部位置</strong> &#x3D; b1的头部位置+b1的方向*b1的长度</p>\n<p>我们只需要算出这些结点的位置，就能知道骨骼的具体走向。</p>\n<p>在Unity中，我们可以通过以下代码实现（假设物体绕Z轴旋转）： </p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Vector3 arm0EndPosition = arm0.position + arm0.right * armLength; </span><br><span class=\"line\">arm1.position = arm0EndPosition; </span><br><span class=\"line\">arm1.rotation = Quaternion.Euler(Vector3.forward * arm1Rotation + arm0.rotation.eulerAngles);</span><br></pre></td></tr></table></figure>\n\n<p>如果想要处理一个骨骼链的话，把上方的逻辑放在循环里,将骨骼放在一个数组里即可。</p>\n<p>FX Test完整代码：</p>\n<figure class=\"highlight c#\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">using</span> System.Collections;</span><br><span class=\"line\"><span class=\"keyword\">using</span> System.Collections.Generic;</span><br><span class=\"line\"><span class=\"keyword\">using</span> UnityEngine;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">L10_FK</span> : <span class=\"title\">MonoBehaviour</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform arm0;<span class=\"comment\">//根骨骼</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform arm1;<span class=\"comment\">//中间的骨骼</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> Transform arm2;<span class=\"comment\">//最外侧的骨骼</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"built_in\">float</span> armLength = <span class=\"number\">2.0f</span>;<span class=\"comment\">//每个骨骼的长度</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"built_in\">float</span> arm1Rotation; <span class=\"comment\">// 控制arm1与arm0的夹角</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Update</span>()</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        arm0.Rotate(<span class=\"number\">0</span>, <span class=\"number\">0</span>, Time.deltaTime * <span class=\"number\">20</span>);  <span class=\"comment\">//在每次update的时候先让arm0转</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 arm0EndPosition = arm0.position + arm0.right * armLength; <span class=\"comment\">//计算arm0结束时候的位置, 位置+方向*长度</span></span><br><span class=\"line\">        arm1.position = arm0EndPosition; <span class=\"comment\">//arm1的头部等于arm0的尾部</span></span><br><span class=\"line\">        arm1.rotation = Quaternion.Euler(Vector3.forward * arm1Rotation + arm0.rotation.eulerAngles);</span><br><span class=\"line\"></span><br><span class=\"line\">        Vector3 arm1EndPosition = arm1.position + arm1.right * armLength;</span><br><span class=\"line\">        arm2.position = arm1EndPosition;</span><br><span class=\"line\">        arm2.rotation = arm1.rotation;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"制作2D骨骼动画（FK）\"><a href=\"#制作2D骨骼动画（FK）\" class=\"headerlink\" title=\"制作2D骨骼动画（FK）\"></a><strong>制作2D骨骼动画（FK）</strong></h1><p>Unity的<strong>Sprite Editor</strong>为我们提供了绑骨（绑定骨骼）的功能。 为了将角色各个部分独立开来方便控制，我们可以使用PSB类型的文件导入Unity。 </p>\n<p>导入后可以在Sprite Editor界面进入<strong>Skinning Editor</strong>（蒙皮编辑器）。其中“蒙皮”的意思就是建立骨骼与外形之间的联系。</p>\n<p>可以看到左侧的选项栏有四个大类：Pose、Bones、Geometry、Weights。 </p>\n<p><strong>Pose</strong>是指角色的姿态，也就是“总览”； </p>\n<p><strong>Bones</strong>是指骨骼； </p>\n<p><strong>Geometry</strong>代表了图片的几何细分（细分为多边形，这样可以像模型一样修改顶点位置以实现变形）； </p>\n<p><strong>Weights</strong>是指图片的每一个部分受到各个骨骼影响的权重</p>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=MTA1NDJkYTVlYTY2Y2JkOTEzYWYzZjkwNDI3ZmRhZTlfYmgwYTZsSVI0eER6UXBvUWtQaHdKbGptQ2RGT1FtMEtfVG9rZW46U1NqUGJIRmlGb2U5dkV4U1RycmNRZ2hFbmhtXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>制作骨骼动画的第一步是进行骨骼绑定。一个较简易的绑骨流程如下： </p>\n<ol>\n<li>选择Auto Geometry为图片生成自动的多边形细分 </li>\n<li>使用Create Bones创建骨骼 </li>\n<li>选择Auto Weights为图片自动生成骨骼权重 </li>\n<li>使用Weights下的其它选项对单个的图层&#x2F;骨骼进行详细修改 </li>\n<li>选择Preview Pose预览绑骨的效果</li>\n</ol>\n<p>在完成绑骨之后，我们就可以开始编辑动画了。</p>\n<p>将导入的prefab拖入场景，打开Gizmos显示即可在Scene窗口中看到角色身上的骨骼。</p>\n<p>我们也可以在左侧Hierarchy窗口中详细查看各个骨骼的GameObject以及它们之间的层级关系。</p>\n<p>实际制作骨骼动画的流程与一般动画的流程并无太大差别：</p>\n<p>使用Animation窗口录制关键帧并在关键帧处设定好骨骼的位置即可。</p>\n<h1 id=\"逆向动力学-IK\"><a href=\"#逆向动力学-IK\" class=\"headerlink\" title=\"逆向动力学 IK\"></a><strong>逆向动力学 IK</strong></h1><p>逆向动力学所解决的问题是<strong>如何拟合各个骨骼以使得骨骼链的末端接近一个位置</strong>。这是一个FK的逆向操作。在IK中有一个新的概念：Target。 </p>\n<p>Target是指<strong>该物体尝试让End Effector到达的位置</strong>。当然也有可能到达不了，比如我要伸手去拿远处桌子上的东西，在我手不够长的情况下，我并不能拿到。但是我能大致伸到那个方向，找到离那个东西最近的一个排布。</p>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=YzlmZTk5YjVmNzM1YjhhODA5YjQyZmU0NWI5MThjOWZfb2xoYnBFelZhczJYcjd2ZWxhdkNjTDBDRDVidklSWktfVG9rZW46U2dydmJCNlNrb0N5MjF4clpGdGNRdU1VblFjXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>当我们对一个健全的IK系统设置Target时，该系统会实时地进行一系列计算来确定每一根骨骼的<strong>位置与旋转</strong>（并不能更改长度！）来让End Effector尽可能地接近Target。</p>\n<p>注意，一个IK系统可能会出现多个解！我们通常需要找到那个“最优解”。 这个问题是个很大的挑战。</p>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=NWI1NDBkNWFjMzhlNTcxOWM4N2QxNWQwYmU4MDRiMTVfZWppOHl4Q3BwQmxZYVVibTNRSEN4c084Z08xM2ttRjRfVG9rZW46T09qeGIxMXBob3U0dEN4NHRwbGNqNEVHbmpjXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<h1 id=\"IK系统的解法\"><a href=\"#IK系统的解法\" class=\"headerlink\" title=\"IK系统的解法\"></a>IK系统的解法</h1><p>在众多数学与物理问题中总会存在两种不同的解答：<strong>数值解</strong>与<strong>解析解</strong>。 </p>\n<p>数值解意味着答案是准确的数字；比如3.1415926536可以说是π的一个“数值解”。</p>\n<p>而解析解是一个使用公式表达的完全精确的解答；</p>\n<p>同样，一个IK问题的解法也分为数值与解析两大块。在游戏开发这个纯应用的场景中，数值解对我们来说更加重要；因为知道了一个数值解（虽然它只是一个近似），我们就可以直接在游戏里使用它们来达成想要的IK效果了。 </p>\n<p>2D IK系统的<strong>数值解法</strong>有以下常见的几种： </p>\n<p>Limb Solver</p>\n<p>Cyclic Coordinate Descent （CCD）Solver</p>\n<p>Forward And Backward Reaching IK （FABRIK）Solver</p>\n<h1 id=\"Limb-Solver-2D\"><a href=\"#Limb-Solver-2D\" class=\"headerlink\" title=\"Limb Solver 2D\"></a><strong>Limb Solver 2D</strong></h1><p>Limb Solver 2D是众多IK算法中最简单的。它用于解<strong>长度为2</strong>的IK系统，也就是说只能有两根骨骼。这也代表着它的限制也是所有算法中最大的。 </p>\n<p>它的计算步骤大致如下： </p>\n<ol>\n<li>计算从根节点到Target的距离<strong>d</strong>。这是整条骨骼链的目标长度。 </li>\n<li>如果<strong>d</strong>大于两根骨骼的长度总和<strong>s</strong>，那么我们无法到达Target。在这个情况下我们只需要将两个骨骼对着Target的方向排成一线即可达到最优解。 </li>\n<li>如果<strong>d</strong>小于<strong>s</strong>的话，我们可以到达Target。这时我们计算出从根节点到Target这条线与根骨骼本身的夹角（使用余弦定理）和两根骨骼之间的夹角。接着我们根据这两个夹角计算出使得End Effector到达Target的一种方法。</li>\n</ol>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=NWVmNTFkNzQ1NzY1MjE1M2E0MTdiMGJmNjNkZWY5MjlfQ295d2UzRmNzQjFUTUt5YmZENnFXZnNtS1JDakliT2RfVG9rZW46RXU3NWI0dlZpb1FGdFp4Zjg4b2M4RVpybmFoXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>这种方法<strong>实现起来较简单</strong>，<strong>计算量也很小，</strong>不过它有着许许多多的限制： </p>\n<ol>\n<li>两根骨骼之间的夹角只能在0和180度之间（顺时针旋转为正）。也就是说它始终只能向一个方向弯曲。 </li>\n<li>它只支持长度为2的IK系统 </li>\n<li>它并不可控，比如我们无法加上旋转角度范围的限制。</li>\n</ol>\n<h1 id=\"CCD-Solver-2D\"><a href=\"#CCD-Solver-2D\" class=\"headerlink\" title=\"CCD Solver 2D\"></a><strong>CCD Solver 2D</strong></h1><p>Cyclic Coordinate Descent （CCD）Solver是一种更加高级、通用的解法。<strong>CCD适用于任意长度的IK问题</strong>。它使用一种迭代的、逐步逼近的方法去获得最优解的近似。</p>\n<p>它的计算步骤大致如下： </p>\n<ol>\n<li><strong>初始化</strong>：算法从End Effector开始 </li>\n<li><strong>旋转</strong>：从End Effector一步步地到根骨骼，计算每一根骨骼到End Effector和它到Target的夹角。旋转该骨骼以最小化这</li>\n</ol>\n<p>个夹角。 </p>\n<ol>\n<li><strong>检查</strong>：如果End Effector和Target的距离已经够近了，结束算法。 </li>\n<li><strong>迭代</strong>：如果没有通过检查，则再迭代一遍。如果已经迭代了x遍了还未通过检查，则算法自动停止。</li>\n</ol>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=OTFhODZlZWYwOWM4MzdlM2U0YjQwMzk4YzliYTFhYmJfZVllazVDY2J4OWRmTnRyVVVLUUUzR0ZyM2tCN2xBR1dfVG9rZW46VlRFd2JpWFZib3RqU0R4UFlxZ2M5SmU4bmtnXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<p>CCD比较灵活、通用，它的<strong>计算量中等</strong>，属于一个比较<strong>中规中矩</strong>的方法（但是这三种算法里性能开销最大的）。 </p>\n<p>CCD比较大的缺点是它并不总能找到“看起来最自然”的解法。 </p>\n<h1 id=\"FABRIK-Solver-2D\"><a href=\"#FABRIK-Solver-2D\" class=\"headerlink\" title=\"FABRIK Solver 2D\"></a><strong>FABRIK Solver 2D</strong></h1><p>Forward And Backward Reaching IK （FABRIK）Solver是另一种<strong>迭代的</strong>、<strong>支持任意长度的</strong>IK解法。就像它的名字一样，它的核心算法是从两头向中间计算。</p>\n<p>它的计算步骤大致如下： </p>\n<ol>\n<li><strong>初始化：</strong>算法从根骨骼开始 </li>\n<li><strong>前向计算：</strong>从根骨骼到End Effector，对于每一根骨骼，将其放置在上一根骨骼和Target的连线方向上（隔一段距离）。全部执行结束后，所有的骨骼会被“拉向”Target，且End Effector一定在Target上。</li>\n</ol>\n<p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc3N2I3NzcxNDYzMTBiM2NmZWQzOWU2N2JiNmUzODNfejdUNngwcTZGd0J1WTZleUdKM0U4aFYxR3hUNFBXb1pfVG9rZW46TzJXemJmVVVibzRGaW54VWdua2N1eUo4bk9mXzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<ol>\n<li><strong>反向计算：</strong>从End Effector到根骨骼，步骤同上，对于每一根骨骼，将其放置在上一根骨骼和Root的连线方向上（隔一段距离）。全部执行结束后，所有的骨骼会被“拉向”根骨骼，但End Effector还在Target上。 </li>\n<li><strong>迭代：</strong>重复第2、3步，直到End Effector与Target的距离够近，或者已达到了最大迭代数量。</li>\n</ol>\n<p>相对于Limb和CCD，这是一种更加成熟的做法。它可以找到看起来<strong>较自然</strong>的解法，而且一般所需要的<strong>迭代次数要小于CCD</strong> （虽然它本身比CCD要复杂）。</p>\n<h1 id=\"IK算法：总结\"><a href=\"#IK算法：总结\" class=\"headerlink\" title=\"IK算法：总结\"></a>IK算法：总结</h1><p><img src=\"https://thinkdifferent-club.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjhkNjllMjBmM2JlZmE1NDAzZjkxNDJiMGQ1NDBmNjNfMUFkNzdicTdXU2xFc1Y5bld0R01KaEpHdkFmYWQzVWZfVG9rZW46THZrM2JTZk1LbzNzV0R4RUhJR2MyTlJLbm41XzE3MDMwNjQ0Nzc6MTcwMzA2ODA3N19WNA\" alt=\"img\"></p>\n<h1 id=\"制作2D骨骼动画（IK）\"><a href=\"#制作2D骨骼动画（IK）\" class=\"headerlink\" title=\"制作2D骨骼动画（IK）\"></a>制作2D骨骼动画（IK）</h1><p>以上三种算法看起来有点复杂，我们每次做骨骼动画都需要写一遍吗？并不需要！Unity已经为我们封装好了这三种算法，我们只需要选就行了。</p>\n<p>在绑定好骨骼后，我们可以通过以下几个步骤制作IK动画： </p>\n<ol>\n<li>首先导入Unity的IKPackage</li>\n<li>将绑好骨的prefab拖入场景中 </li>\n<li>创建一个空物体，并添加IKManager2D组件 </li>\n<li>在IKSolvers选项下添加一个新的IKSolver并选择想要使用的算法（Limb、CCD、FABRIK） </li>\n<li>选中IKSolver组件，并拖入Effector（End Effector）和Target的Transform </li>\n<li>在IKSolver组件中进行相关设置（骨骼链长度、迭代次数等等） </li>\n<li>拖动Target即可看见IK效果 </li>\n<li>在Animation窗口对Target录制Transform动画即可</li>\n</ol>\n","feature":true,"text":"概述本次分享主要介绍骨骼动画与IK，内容包含骨骼动画简介，正向动力学FK，2D 骨骼动画实践，逆向动力学IK，Limb Solver、CCD Solver、FA...","permalink":"/post/骨骼动画与IK","photos":[],"count_time":{"symbolsCount":"5.7k","symbolsTime":"5 mins."},"categories":[],"tags":[{"name":"Unity开发","slug":"Unity开发","count":2,"path":"api/tags/Unity开发.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">骨骼动画简介</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB-%E5%B8%A7%E5%8A%A8%E7%94%BB\"><span class=\"toc-text\">骨骼动画 &amp; 帧动画</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#FK-IK\"><span class=\"toc-text\">FK &amp; IK</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%AD%A3%E5%90%91%E5%8A%A8%E5%8A%9B%E5%AD%A6FK%EF%BC%88%E7%9F%A5%E9%81%93%E8%BF%87%E7%A8%8B%E6%8E%A8%E5%AF%BC%E7%BB%93%E6%9E%9C%EF%BC%89\"><span class=\"toc-text\">正向动力学FK（知道过程推导结果）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97FK%E6%9C%AB%E7%AB%AF%E5%99%A8%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">计算FK末端器的状态</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%B6%E4%BD%9C2D%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%EF%BC%88FK%EF%BC%89\"><span class=\"toc-text\">制作2D骨骼动画（FK）</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E9%80%86%E5%90%91%E5%8A%A8%E5%8A%9B%E5%AD%A6-IK\"><span class=\"toc-text\">逆向动力学 IK</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IK%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%A7%A3%E6%B3%95\"><span class=\"toc-text\">IK系统的解法</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Limb-Solver-2D\"><span class=\"toc-text\">Limb Solver 2D</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CCD-Solver-2D\"><span class=\"toc-text\">CCD Solver 2D</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#FABRIK-Solver-2D\"><span class=\"toc-text\">FABRIK Solver 2D</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IK%E7%AE%97%E6%B3%95%EF%BC%9A%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">IK算法：总结</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%B6%E4%BD%9C2D%E9%AA%A8%E9%AA%BC%E5%8A%A8%E7%94%BB%EF%BC%88IK%EF%BC%89\"><span class=\"toc-text\">制作2D骨骼动画（IK）</span></a></li></ol>","author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"Socket基础","uid":"514d1808d25e64b8077292b0b40d87f8","slug":"Socket学习记录","date":"2023-11-07T12:41:10.000Z","updated":"2024-12-08T14:02:09.078Z","comments":true,"path":"api/articles/Socket学习记录.json","keywords":null,"cover":[],"text":"Socket基础客户端：1. Socket的初始化与连接操作12345678910private Socket _socket; void Start()&#1...","permalink":"/post/Socket学习记录","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[],"tags":[{"name":"Unity网络开发","slug":"Unity网络开发","count":2,"path":"api/tags/Unity网络开发.json"}],"author":{"name":"sasigiii","slug":"blog-author","avatar":"\\images\\头像.PNG","link":"/","description":"一位正在重塑知识的技术人","socials":{"github":"https://github.com/Sasigiii","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/tridiamond","csdn":"https://blog.csdn.net/TriDiamond6","juejin":"","customs":{}}},"feature":true}}