[{"id":"12b449f4e20ce22d5fbbca66571d4052","title":"骨骼动画与IK","content":"概述本次分享主要介绍骨骼动画与IK，内容包含骨骼动画简介，正向动力学FK，2D 骨骼动画实践，逆向动力学IK，Limb Solver、CCD Solver、FABRIK Solver，2D IK动画实践 。\n骨骼动画简介骨骼动画（Skeletal Animation &#x2F; Rigging）是一种由“骨骼”来控制物体外形的技术。所谓“骨骼”，其实就是一组相互连接的，有层级的结构。这就像人体的骨骼决定了人体的外形（肌肉、皮肤）一样。\n\n可以看到每一根骨骼由一个方向和一个长度组成。骨骼的头部由圆点表示，而尾部由尖端表示。 \n骨骼的层级结构是很清晰的：一根骨骼A的头部与另一根B的尾部相连则代表A是B的“孩子”，即A的位置与旋转继承自B。\n骨骼动画 &amp; 帧动画在2D开发的情况中，动画主要分为两种：骨骼动画与帧动画。其中帧动画指的是在一段时间内每k帧替换一张图片，使得物体看起来正在动一样。比如所有手绘的动画作品都是帧动画。 \n帧动画的优点是每一帧我们都可以单独定制，所以它极其可控；而它的缺点是占用空间较大（因为每一张图片要单独存储，如果我们要一个30帧的动画，每秒钟就要30张图片）且帧率有限（我们无法在两个关键帧之间插值）。\n而骨骼动画实质上是一种程序化动画。它最大的优点是实时性：这意味着它的帧率由游戏帧率决定，且我们可以实时地修改、控制它。其次，它的占用空间也会小很多（因为我们只需要记录各个关键帧上骨骼的数据就可以了，这比图片小很多）。 \nFK &amp; IK一般来说骨骼动画可以被分为两个类型：正向动力学（FK）与逆向动力学（IK）。简单来说，FK是一个已知过程再推导处结果的方法，而IK则相反：它是一个通过结果逆向推导出过程的方法。\n\nFK可以帮助我们通过L1 – L4（q1 – q4）四个关节的位置与旋转来计算出上方机械臂末端的位置与旋转。\nIK则可以通过机械臂末端的位置与旋转推导出L1 – L4 （q1 – q4）的形态。\nIK明显比FK要复杂很多，IK由起点和终点的位置与旋转进行推导，得出的过程有多种。我们怎么才能得到正确的走法呢？\n我们先从FK入手，方便更好的理解IK的算法。\n正向动力学FK（知道过程推导结果）FK相较于IK来说要简单许多。它也更符合我们对骨骼动画的初步认知。\n在一个FK系统中，有这些重要的概念： \n\nJoint（关节）：这是骨骼的头部，用来控制旋转， 就像是胳膊肘和手腕。\nLinks（连接）：这是骨骼的尾部，用来控制长度与和其它骨骼的连接，这些连接可以用来表示和其他骨骼的继承关系。 \nEnd-Effector（末端器）：这是整条骨骼的尾部。 \nKinematic Chain（动力学链）：这代表了一整条彼此相连的骨骼。\n\n\n由以上概念可以知道FK的本质是确定末端器的状态，但其实每一个骨骼都可以被看作一个末端器（为什么？）；于是我们可以通过FK确定整条骨骼具体的形态。\n\n因此我们可以由第一个末端器推出第二个末端器的位置，再由第二个末端器的位置推出第三个末端器的位置，以此类推。\nFK就是从头到尾递推出整根骨骼的形态，最后我们再把整个骨骼的形态应用到物体上。\n计算FK末端器的状态对于一根骨骼b1，想要计算它的状态我们只需要知道它的“根骨骼”b0的状态即可。 \nb1的头部位置 &#x3D; b0的尾部位置 &#x3D; b0的头部位置+b0的方向*b0的长度 \nb1的尾部位置 &#x3D; b1的头部位置+b1的方向*b1的长度\n我们只需要算出这些结点的位置，就能知道骨骼的具体走向。\n在Unity中，我们可以通过以下代码实现（假设物体绕Z轴旋转）： \n123Vector3 arm0EndPosition = arm0.position + arm0.right * armLength; arm1.position = arm0EndPosition; arm1.rotation = Quaternion.Euler(Vector3.forward * arm1Rotation + arm0.rotation.eulerAngles);\n\n如果想要处理一个骨骼链的话，把上方的逻辑放在循环里,将骨骼放在一个数组里即可。\nFX Test完整代码：\n123456789101112131415161718192021222324252627using System.Collections;using System.Collections.Generic;using UnityEngine;public class L10_FK : MonoBehaviour&#123;    public Transform arm0;//根骨骼    public Transform arm1;//中间的骨骼    public Transform arm2;//最外侧的骨骼    private float armLength = 2.0f;//每个骨骼的长度    public float arm1Rotation; // 控制arm1与arm0的夹角    void Update()    &#123;        arm0.Rotate(0, 0, Time.deltaTime * 20);  //在每次update的时候先让arm0转        Vector3 arm0EndPosition = arm0.position + arm0.right * armLength; //计算arm0结束时候的位置, 位置+方向*长度        arm1.position = arm0EndPosition; //arm1的头部等于arm0的尾部        arm1.rotation = Quaternion.Euler(Vector3.forward * arm1Rotation + arm0.rotation.eulerAngles);        Vector3 arm1EndPosition = arm1.position + arm1.right * armLength;        arm2.position = arm1EndPosition;        arm2.rotation = arm1.rotation;    &#125;&#125;\n\n制作2D骨骼动画（FK）Unity的Sprite Editor为我们提供了绑骨（绑定骨骼）的功能。 为了将角色各个部分独立开来方便控制，我们可以使用PSB类型的文件导入Unity。 \n导入后可以在Sprite Editor界面进入Skinning Editor（蒙皮编辑器）。其中“蒙皮”的意思就是建立骨骼与外形之间的联系。\n可以看到左侧的选项栏有四个大类：Pose、Bones、Geometry、Weights。 \nPose是指角色的姿态，也就是“总览”； \nBones是指骨骼； \nGeometry代表了图片的几何细分（细分为多边形，这样可以像模型一样修改顶点位置以实现变形）； \nWeights是指图片的每一个部分受到各个骨骼影响的权重\n\n制作骨骼动画的第一步是进行骨骼绑定。一个较简易的绑骨流程如下： \n\n选择Auto Geometry为图片生成自动的多边形细分 \n使用Create Bones创建骨骼 \n选择Auto Weights为图片自动生成骨骼权重 \n使用Weights下的其它选项对单个的图层&#x2F;骨骼进行详细修改 \n选择Preview Pose预览绑骨的效果\n\n在完成绑骨之后，我们就可以开始编辑动画了。\n将导入的prefab拖入场景，打开Gizmos显示即可在Scene窗口中看到角色身上的骨骼。\n我们也可以在左侧Hierarchy窗口中详细查看各个骨骼的GameObject以及它们之间的层级关系。\n实际制作骨骼动画的流程与一般动画的流程并无太大差别：\n使用Animation窗口录制关键帧并在关键帧处设定好骨骼的位置即可。\n逆向动力学 IK逆向动力学所解决的问题是如何拟合各个骨骼以使得骨骼链的末端接近一个位置。这是一个FK的逆向操作。在IK中有一个新的概念：Target。 \nTarget是指该物体尝试让End Effector到达的位置。当然也有可能到达不了，比如我要伸手去拿远处桌子上的东西，在我手不够长的情况下，我并不能拿到。但是我能大致伸到那个方向，找到离那个东西最近的一个排布。\n\n当我们对一个健全的IK系统设置Target时，该系统会实时地进行一系列计算来确定每一根骨骼的位置与旋转（并不能更改长度！）来让End Effector尽可能地接近Target。\n注意，一个IK系统可能会出现多个解！我们通常需要找到那个“最优解”。 这个问题是个很大的挑战。\n\nIK系统的解法在众多数学与物理问题中总会存在两种不同的解答：数值解与解析解。 \n数值解意味着答案是准确的数字；比如3.1415926536可以说是π的一个“数值解”。\n而解析解是一个使用公式表达的完全精确的解答；\n同样，一个IK问题的解法也分为数值与解析两大块。在游戏开发这个纯应用的场景中，数值解对我们来说更加重要；因为知道了一个数值解（虽然它只是一个近似），我们就可以直接在游戏里使用它们来达成想要的IK效果了。 \n2D IK系统的数值解法有以下常见的几种： \nLimb Solver\nCyclic Coordinate Descent （CCD）Solver\nForward And Backward Reaching IK （FABRIK）Solver\nLimb Solver 2DLimb Solver 2D是众多IK算法中最简单的。它用于解长度为2的IK系统，也就是说只能有两根骨骼。这也代表着它的限制也是所有算法中最大的。 \n它的计算步骤大致如下： \n\n计算从根节点到Target的距离d。这是整条骨骼链的目标长度。 \n如果d大于两根骨骼的长度总和s，那么我们无法到达Target。在这个情况下我们只需要将两个骨骼对着Target的方向排成一线即可达到最优解。 \n如果d小于s的话，我们可以到达Target。这时我们计算出从根节点到Target这条线与根骨骼本身的夹角（使用余弦定理）和两根骨骼之间的夹角。接着我们根据这两个夹角计算出使得End Effector到达Target的一种方法。\n\n\n这种方法实现起来较简单，计算量也很小，不过它有着许许多多的限制： \n\n两根骨骼之间的夹角只能在0和180度之间（顺时针旋转为正）。也就是说它始终只能向一个方向弯曲。 \n它只支持长度为2的IK系统 \n它并不可控，比如我们无法加上旋转角度范围的限制。\n\nCCD Solver 2DCyclic Coordinate Descent （CCD）Solver是一种更加高级、通用的解法。CCD适用于任意长度的IK问题。它使用一种迭代的、逐步逼近的方法去获得最优解的近似。\n它的计算步骤大致如下： \n\n初始化：算法从End Effector开始 \n旋转：从End Effector一步步地到根骨骼，计算每一根骨骼到End Effector和它到Target的夹角。旋转该骨骼以最小化这\n\n个夹角。 \n\n检查：如果End Effector和Target的距离已经够近了，结束算法。 \n迭代：如果没有通过检查，则再迭代一遍。如果已经迭代了x遍了还未通过检查，则算法自动停止。\n\n\nCCD比较灵活、通用，它的计算量中等，属于一个比较中规中矩的方法（但是这三种算法里性能开销最大的）。 \nCCD比较大的缺点是它并不总能找到“看起来最自然”的解法。 \nFABRIK Solver 2DForward And Backward Reaching IK （FABRIK）Solver是另一种迭代的、支持任意长度的IK解法。就像它的名字一样，它的核心算法是从两头向中间计算。\n它的计算步骤大致如下： \n\n初始化：算法从根骨骼开始 \n前向计算：从根骨骼到End Effector，对于每一根骨骼，将其放置在上一根骨骼和Target的连线方向上（隔一段距离）。全部执行结束后，所有的骨骼会被“拉向”Target，且End Effector一定在Target上。\n\n\n\n反向计算：从End Effector到根骨骼，步骤同上，对于每一根骨骼，将其放置在上一根骨骼和Root的连线方向上（隔一段距离）。全部执行结束后，所有的骨骼会被“拉向”根骨骼，但End Effector还在Target上。 \n迭代：重复第2、3步，直到End Effector与Target的距离够近，或者已达到了最大迭代数量。\n\n相对于Limb和CCD，这是一种更加成熟的做法。它可以找到看起来较自然的解法，而且一般所需要的迭代次数要小于CCD （虽然它本身比CCD要复杂）。\nIK算法：总结\n制作2D骨骼动画（IK）以上三种算法看起来有点复杂，我们每次做骨骼动画都需要写一遍吗？并不需要！Unity已经为我们封装好了这三种算法，我们只需要选就行了。\n在绑定好骨骼后，我们可以通过以下几个步骤制作IK动画： \n\n首先导入Unity的IKPackage\n将绑好骨的prefab拖入场景中 \n创建一个空物体，并添加IKManager2D组件 \n在IKSolvers选项下添加一个新的IKSolver并选择想要使用的算法（Limb、CCD、FABRIK） \n选中IKSolver组件，并拖入Effector（End Effector）和Target的Transform \n在IKSolver组件中进行相关设置（骨骼链长度、迭代次数等等） \n拖动Target即可看见IK效果 \n在Animation窗口对Target录制Transform动画即可\n\n","slug":"骨骼动画与IK","date":"2023-12-20T09:26:43.000Z","categories_index":"","tags_index":"Unity开发","author_index":"sasigiii"},{"id":"33f1db3ba8f93ed1537346a0403c58d0","title":"Pytorch深度学习引言","content":"参数参数（parameter）可以被看做旋钮，旋钮的转动可以调整程序的行为。即可以通过改变参数来调节模型的行为。\n模型任一调整参数后的程序被称为模型（model）。通过操作参数而生成的所有不同程序(输入-输出映射)的集合被称为“模型族”。使用数据集（dataset）来选择参数的元程序被称为学习算法（learning algorithm）。\n在开始用机器学习算法解决问题之前，我们必须精确地定义问题，来确定输入(input)和输出(output)的性质，并选择合适的模型族。比如模型接收一段音频作为输入，然后再是或否中生成一个选择来作为输出。如果一切都顺利，经过一番训练，模型对于 “片段是否包含唤醒词”的预测通常是正确的。\n机器学习在机器学习中，学习（learning）是一个训练模型的过程。 通过这个过程，我们可以发现正确的参数集，从而使模型强制执行所需的行为。 换句话说，我们用数据训练（train）模型。 如 图1.1.2所示，训练过程通常包含如下步骤：\n\n从一个随机初始化参数的模型开始，这个模型基本没有“智能”；\n获取一些数据样本（例如，音频片段以及对应的是或否标签）；\n调整参数，使模型在这些样本中表现得更好；\n重复第（2）步和第（3）步，直到模型在任务中的表现令人满意。\n\n\n​                                                             图1.1.2* 一个典型的训练过程\n总而言之，我们没有编写唤醒词识别器，而是编写了一个“学习”程序。 如果我们用一个巨大的带标签的数据集，它很可能可以“学习”识别唤醒词。 这种“通过用数据集来确定程序行为”的方法可以被看作用数据编程（programming with data）。\n机器学习中的关键组件首先介绍一些核心组件。无论什么类型的机器学习问题，都会遇到这些组件：\n\n可以用来学习的数据（data）；\n如何转换数据的模型（model）；\n一个目标函数（objective function），用来量化模型的有效性；\n调整模型参数以优化目标函数的算法（algorithm）。\n\n数据每个数据集由一个个样本（example, sample）组成，大多时候，它们遵循独立同分布(independently and identically distributed, i.i.d.)。 样本有时也叫做数据点（data point）或者数据实例（data instance），通常每个样本由一组称为特征（features，或协变量（covariates））的属性组成。 机器学习模型会根据这些属性进行预测。 在上面的监督学习问题中，要预测的是一个特殊的属性，它被称为标签（label，或目标（target））。\n当处理图像数据时，每一张单独的照片即为一个样本，它的特征由每个像素数值的有序列表表示。 比如，200×200彩色照片由200×200×3&#x3D;120000个数值组成，其中的“3”对应于每个空间位置的红、绿、蓝通道的强度。 再比如，对于一组医疗数据，给定一组标准的特征（如年龄、生命体征和诊断），此数据可以用来尝试预测患者是否会存活。\n当每个样本的特征类别数量都是相同的时候，其特征向量是固定长度的，这个长度被称为数据的维数（dimensionality）。 固定长度的特征向量是一个方便的属性，它可以用来量化学习大量样本。\n然而，并不是所有的数据都可以用“固定长度”的向量表示。例如淘宝上的购物评价，有的很简短，有的又是长篇大论。与传统的机器学习相比，深度学习的一个主要优势是可以处理不同长度的数据。\n模型深度学习与经典方法的区别主要在于：前者关注的功能强大的模型，这些模型由神经网络错综复杂的交织在一起，包含层层数据转换，因此被称为深度学习（deep learning）。\n目标函数在机器学习中，我们需要定义模型的优劣程度的度量，这个度量在大多数情况是“可优化”的，这被称之为目标函数（objective function）。 我们通常定义一个目标函数，并希望优化它到最低点。 因为越低越好，所以这些函数有时被称为损失函数（loss function，或cost function）。 但这只是一个惯例，我们也可以取一个新的函数，优化到它的最高点。 这两个函数本质上是相同的，只是翻转一下符号。\n目标函数当任务在试图预测数值时，最常见的损失函数是平方误差（squared error），即预测值与实际值之差的平方。 当试图解决分类问题时，最常见的目标函数是最小化错误率，即预测与实际情况不符的样本比例。 有些目标函数（如平方误差）很容易被优化，有些目标（如错误率）由于不可微性或其他复杂性难以直接优化。 在这些情况下，通常会优化替代目标。\n通常，损失函数是根据模型参数定义的，并取决于数据集。 在一个数据集上，我们可以通过最小化总损失来学习模型参数的最佳值。 该数据集由一些为训练而收集的样本组成，称为训练数据集（training dataset，或称为训练集（training set））。 然而，在训练数据上表现良好的模型，并不一定在“新数据集”上有同样的性能，这里的“新数据集”通常称为测试数据集（test dataset，或称为测试集（test set））。\n综上所述，可用数据集通常可以分成两部分：训练数据集用于拟合模型参数，测试数据集用于评估拟合的模型。 然后我们观察模型在这两部分数据集的性能。 “一个模型在训练数据集上的性能”可以被想象成“一个学生在模拟考试中的分数”。 这个分数用来为一些真正的期末考试做参考，即使成绩令人鼓舞，也不能保证期末考试成功。 换言之，测试性能可能会显著偏离训练性能。 当一个模型在训练集上表现良好，但不能推广到测试集时，这个模型被称为过拟合（overfitting）的。 就像在现实生活中，尽管模拟考试考得很好，真正的考试不一定百发百中。\n优化算法当我们获得了一些数据源及其表示、一个模型和一个合适的损失函数，接下来就需要一种算法，它能够搜索出最佳参数，以最小化损失函数。 深度学习中，大多流行的优化算法通常基于一种基本方法–梯度下降（gradient descent）。 简而言之，在每个步骤中，梯度下降法都会检查每个参数，看看如果仅对该参数进行少量变动，训练集损失会朝哪个方向移动。 然后，它在可以减少损失的方向上优化参数。\n各种机器学习问题监督学习监督学习（supervised learning）擅长在“给定输入特征”的情况下预测标签。 每个“特征-标签”对都称为一个样本（example）。 有时，即使标签是未知的，样本也可以指代输入特征。 我们的目标是生成一个模型，能够将任何输入特征映射到标签（即预测）。\n举一个具体的例子： 假设我们需要预测患者的心脏病是否会发作，那么观察结果“心脏病发作”或“心脏病没有发作”将是样本的标签。 输入特征可能是生命体征，如心率、舒张压和收缩压等。\n在一定程度上，许多重要的任务可以清晰地描述为，在给定一组特定的可用数据的情况下，估计未知事物的概率。\n监督学习的学习过程一般可以分为三大步骤：\n\n从已知大量数据样本中随机选取一个子集，为每个样本获取真实标签。有时，这些样本已有标签（例如，患者是否在下一年内康复？）；有时，这些样本可能需要被人工标记（例如，图像分类）。这些输入和相应的标签一起构成了训练数据集；\n选择有监督的学习算法，它将训练数据集作为输入，并输出一个“已完成学习的模型”；\n将之前没有见过的样本特征放到这个“已完成学习的模型”中，使用模型的输出作为相应标签的预测。\n\n整个监督学习过程如 图1.3.1 所示。\n\n​                                                                   图1.3.1 监督学习\n综上所述，即使使用简单的描述给定输入特征的预测标签，监督学习也可以采取多种形式的模型，并且需要大量不同的建模决策，这取决于输入和输出的类型、大小和数量。 例如，我们使用不同的模型来处理“任意长度的序列”或“固定长度的序列”。\n回归回归（regression）是最简单的监督学习任务之一。 假设有一组房屋销售数据表格，其中每行对应一个房子，每列对应一个相关的属性，例如房屋的面积、卧室的数量、浴室的数量以及到镇中心的步行距离，等等。 每一行的属性构成了一个房子样本的特征向量。 如果一个人住在纽约或旧金山，那么他家的特征向量（房屋面积，卧室数量，浴室数量，步行距离）可能类似于：[600,1,1,60]。 如果一个人住在匹兹堡，这个特征向量可能更接近[3000,4,3,10]…… 当人们在市场上寻找新房子时，可能需要估计一栋房子的公平市场价值。 为什么这个任务可以归类为回归问题呢？本质上是输出决定的。 销售价格（即标签）是一个数值。 当标签取任意数值时，我们称之为回归问题，此时的目标是生成一个模型，使它的预测非常接近实际标签值。\n总而言之，判断回归问题的一个很好的经验法则是，任何有关“有多少”的问题很可能就是回归问题。\n分类虽然回归模型可以很好地解决“有多少”的问题，但是很多问题并非如此。 例如，一家银行希望在其移动应用程序中添加支票扫描功能。 具体地说，这款应用程序能够自动理解从图像中看到的文本，并将手写字符映射到对应的已知字符之上。 这种“哪一个”的问题叫做分类（classification）问题。\n *分类问题希望模型能够预测样本属于哪个*类别（category，正式称为类（class））。例如，手写数字可能有10类，标签被设置为数字0～9。 最简单的分类问题是只有两类，这被称之为二项分类（binomial classification）。 例如，数据集可能由动物图像组成，标签可能是猫狗{猫,狗}两类。 当有两个以上的类别时，我们把这个问题称为多项分类（multiclass classification）问题。常见的例子包括手写字符识别{0,1,2,…9,a,b,c,…}。与解决回归问题不同，分类问题的常见损失函数被称为交叉熵（cross-entropy）。**\n回归是训练一个回归函数来输出一个数值； 分类是训练一个分类器来输出预测的类别。\n标记问题学习预测不相互排斥的类别的问题称为多标签分类（multi-label classification）。\n","slug":"Pytorch深度学习引言","date":"2023-11-07T12:41:10.000Z","categories_index":"","tags_index":"Pytorch深度学习","author_index":"sasigiii"},{"id":"514d1808d25e64b8077292b0b40d87f8","title":"Socket基础","content":"Socket基础客户端：1. Socket的初始化与连接操作12345678910private Socket _socket;        void Start()&#123;    // Socket的初始化 参数1: 地址族(ipv4) 参数2: 套接字类型(流式传输) 参数3: 协议类型(TCP)    _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, \tProtocolType.Tcp);    // 连接服务器 参数1: 服务器地址 参数2: 服务器端口    _socket.Connect(&quot;127.0.0.1&quot;, 6666);&#125;\n\n\n\n2.  Socket的开始接收消息1234_socket.BeginReceive方法和_socket.BeginAccept方法的区别：_socket.BeginAccept()和_socket.BeginReceive()是用于异步操作的Socket方法，但它们的用途不同：_socket.BeginAccept(): 开始异步操作以接受传入的连接尝试。通常用于服务器端，等待客户端连接。_socket.BeginReceive(): 开始异步操作以从连接的Socket接收数据。通常用于客户端或服务器端，接收已经建立连接后的数据。\n\n1234567891011121314151617181920212223242526/// &lt;summary&gt;/// 消息的接收/// &lt;/summary&gt;private void StartReceive()&#123;    // 开始接收消息    // 参数分别是 接收缓冲区, 从第0个字节开始, 缓冲区的长度, 接收消息的方式, 回调函数, 回调函数的参数    _socket.BeginReceive(_buffer, 0, _buffer.Length, SocketFlags.None, ReceiveCallback, null);&#125;// 若接收到了消息便会在这个回调函数里进行处理private void ReceiveCallback(IAsyncResult ar)&#123;    // 存放消息的长度    int len = _socket.EndReceive(ar);    // 如果消息长度为0, 说明客户端断开了连接    if (len == 0)    &#123;        _socket.Close();        return;    &#125;    // 将接收到的消息转换为字符串 参数1: 缓冲区 参数2: 从第0个字节开始 参数3: 消息长度    string msg = System.Text.Encoding.UTF8.GetString(_buffer, 0, len);    Debug.Log(msg);&#125;\n\n如果像现在这样写，那么客户端只能接受一次来自服务端的消息并解析，如果服务端再发消息过来，客户端就不会再有响应了。\n因此我们需要在回调里面递归调用StartReceive()方法来确保客户端能响应后续服务端的消息。\n123456789101112131415161718// 若接收到了消息便会在这个回调函数里进行处理private void ReceiveCallback(IAsyncResult ar)&#123;    // 存放消息的长度    int len = _socket.EndReceive(ar);    // 如果消息长度为0, 说明客户端断开了连接    if (len == 0)    &#123;        _socket.Close();        return;    &#125;        // 将接收到的消息转换为字符串 参数1: 缓冲区 参数2: 从第0个字节开始 参数3: 消息长度    string msg = System.Text.Encoding.UTF8.GetString(_buffer, 0, len);    Debug.Log(msg);    // 继续接收消息    StartReceive();&#125;\n\n这样一来我们客户端的Socket的代码就创建好了。\n服务端：服务端和客户端的处理流程大致相似，只是多了一步监听操作\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778using System.Net;using System.Net.Sockets;namespace UnitySocketServer&#123;    class Program    &#123;        private static Socket? _serverSocket = null;        private static readonly byte[] Buffer = new byte[1024];        static void Main(string[] args)        &#123;            // 参数1: 地址族(ipv4) 参数2: 套接字类型(流式传输) 参数3: 协议类型(TCP)            _serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);            // 绑定服务器地址和端口            // IPEndPoint是一个包含IP地址和端口号的类            _serverSocket.Bind(new IPEndPoint(IPAddress.Any, 6666));            // 开始监听 参数1: 最大连接数(同一时间最多有多少个客户端连接)            _serverSocket.Listen(0);                        StartAccept();                        // 阻止程序结束            System.Console.ReadLine();        &#125;        private static void StartAccept()        &#123;            // 开始接收客户端连接 参数1: 回调函数 参数2: 回调函数的参数            _serverSocket?.BeginAccept(AcceptCallback, null);        &#125;                        /// &lt;summary&gt;        /// 回调函数 当有客户端连接时会调用这个函数        /// &lt;/summary&gt;        /// &lt;param name=&quot;ar&quot;&gt;&lt;/param&gt;        private static void AcceptCallback(IAsyncResult ar)        &#123;            // 获取客户端的Socket EndAccept会返回一个Socket            Socket? client = _serverSocket?.EndAccept(ar);                        // 处理客户端的消息            StartReceive(client);                        // 和客户端同理, 继续接收消息            StartAccept();        &#125;                private static void StartReceive(Socket? client)        &#123;            // 开始接收消息            // 参数分别是 接收缓冲区, 从第0个字节开始, 缓冲区的长度, 接收消息的方式, 回调函数, 回调函数的参数            // 回调函数的参数要传入一个Socket, 方便回调函数处理不同的客户端的消息。如果不传入Socket, 那么回调函数就无法区分不同的客户端            client?.BeginReceive(Buffer, 0, Buffer.Length, SocketFlags.None, ReceiveCallback, client);        &#125;        private static void ReceiveCallback(IAsyncResult ar)        &#123;            // 获取客户端的Socket 为null则抛出异常            Socket? client = ar.AsyncState as Socket ?? throw new InvalidOperationException();            // 存放消息的长度            int len = client.EndReceive(ar);            // 如果消息长度为0, 说明客户端断开了连接            if (len == 0)            &#123;                client.Close();                return;            &#125;                        string msg = System.Text.Encoding.UTF8.GetString(Buffer, 0, len);            // 输出消息            System.Console.WriteLine(msg);            // 继续接收消息            StartReceive(client);        &#125;    &#125;&#125;\n\n\n\n需要注意的是服务端接受到了客户端的Socket进行解析消息，使用的是客户端的Socket而不是服务端的Socket。\nStartReceive(client); 被调用是为了开始从已连接的客户端接收数据。这个方法在客户端的套接字上启动一个异步读取操作。以下是逐步解释：\n\n启动异步接收：在 StartReceive(client) 方法中调用 client.BeginReceive，这会启动一个异步操作来从客户端套接字读取数据。\n缓冲区和回调：该方法指定了一个缓冲区来存储接收到的数据，并指定了一个回调方法 (ReceiveCallback) 来处理接收到的数据。\n持续接收数据：通过在 ReceiveCallback 方法中再次调用 StartReceive(client)，服务器确保它继续监听来自客户端的更多数据。\n\n这样，服务器可以连续且异步地处理来自客户端的传入数据。\n完善客户端：对客户端编写一个Send脚本来向服务器发送信息。\n1234private void Send()&#123;    _socket.Send(Encoding.UTF8.GetBytes(&quot;Hello Server&quot;));&#125;\n\n123456789101112private void Start()&#123;    // Socket的初始化 参数1: 地址族(ipv4) 参数2: 套接字类型(流式传输) 参数3: 协议类型(TCP)    _socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);    // 连接服务器 参数1: 服务器地址 参数2: 服务器端口    _socket.Connect(&quot;127.0.0.1&quot;, 6666);    // 开始接收消息    StartReceive();        // 发送消息    Send();&#125;\n\n在Start方法中，_socket.Connect(“127.0.0.1”, 6666);已经同步地连接到服务器。如果连接失败，会抛出异常，后续的代码不会执行。因此，在调用Send()方法时，可以确保已经成功连接到服务器。\n成功收到客户端发来的信息：\n\n如果要向客户端发送消息使用的也应该是客户端的Socket。\n12// 发送消息到客户端client.Send(System.Text.Encoding.UTF8.GetBytes(&quot;Hello Client&quot;));\n\n客户端成功接受到消息：\n\nsocket联机游戏制作服务端如何管理客户端的连接和服务器消息解析设计思路：总体流程和上文一致，但是将服务器的启动单独拆分为了 UnityServer类，将客户端的Socket拆分为了UnityClient类便于管理。当监听到有客户端连接进服务器时会new一个UnityClient, 所有的消息解析和服务器对客户端的数据流发送均由此类进行管理。对于存放消息流的buffer,单独维护一个Message类进行管理，该类将具有对消息的存放和对协议的解析(这里使用Protobuf)。\nUnityServer:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445using System.Net;using System.Net.Sockets;namespace UnitySocketServer.Servers;public class UnityServer&#123;    // 服务器的Socket    private Socket _serverSocket;    // 客户端的列表    private List&lt;UnityClient&gt; _unityClients = new List&lt;UnityClient&gt;();        // 构造函数 执行了构造函数服务器就正式启动    public UnityServer() &#123; &#125;    // 构造函数 指定端口    public UnityServer(int port)    &#123;        _serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);                // 进行绑定        _serverSocket.Bind(new IPEndPoint(IPAddress.Any, port));         _serverSocket.Listen(0);                // 开始应答处理客户端的连接        StartAccept();    &#125;    // 开始应答    private void StartAccept()    &#123;        _serverSocket.BeginAccept(AcceptCallback, null);    &#125;        // 应答回调    private void AcceptCallback(IAsyncResult ar)    &#123;        Socket clientSocket = _serverSocket.EndAccept(ar);        _unityClients.Add(new UnityClient(clientSocket));        // 继续应答        StartAccept();    &#125;&#125;\n\nUnityClient:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System.Net.Sockets;using UnitySocketServer.Tools;namespace UnitySocketServer.Servers;public class UnityClient&#123;    private Socket _clientSocket;    private Message _message;        // 构造函数    public UnityClient(Socket clientSocket)    &#123;        _clientSocket = clientSocket;        _message = new Message();        StartReceive();    &#125;    // 解析消息    private void StartReceive()    &#123;        _clientSocket.BeginReceive(_message.Buffer,_message.StartIndex,_message.Remsize, SocketFlags.None, ReceiveCallBack, null);    &#125;    // 解析的回调    private void ReceiveCallBack(IAsyncResult ar)    &#123;        try        &#123;            if(_clientSocket == null || _clientSocket.Connected == false)            &#123;                return;            &#125;            int len = _clientSocket.EndReceive(ar);            if (len == 0)            &#123;                return;            &#125;            _message.ReadBuffer(len);            StartReceive();        &#125;        catch (Exception e)        &#123;            Console.WriteLine(e);            throw;        &#125;    &#125;&#125;\n\nMessage：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152using SocketGameProtocol;namespace UnitySocketServer.Tools;public class Message&#123;    private readonly byte[] _buffer = new byte[1024];    // 代表了buffer存到了第几位，主要是处理黏包的问题    private int _startIndex;    // 外界获取_buffer    public byte[] Buffer =&gt; _buffer;    // 外界获取startIndex    public int StartIndex =&gt; _startIndex;        // 剩余的空间    public int Remsize =&gt; _buffer.Length - _startIndex;        /// &lt;summary&gt;    ///解析消息    /// &lt;/summary&gt;    /// &lt;param name=&quot;len&quot;&gt;没接收的消息长度&lt;/param&gt;    public void ReadBuffer(int len)    &#123;        _startIndex += len;        // 这个4是消息头的长度 4个字节 如果小于4说明消息头都没接收完或只有包头没有包体 包肯定不完整        if (_startIndex &lt;= 4)        &#123;            return;        &#125;                // 获取消息的长度 是整段消息的长度，包括消息头和包体的长度。        int count = BitConverter.ToInt32(_buffer, 0);        while (true)        &#123;            if (_startIndex &gt;= (count + 4))            &#123;                MainPack pack = (MainPack)MainPack.Descriptor.Parser.ParseFrom(_buffer, 4, count);                // 重置startIndex                _startIndex -= (count + 4);                // 将后面的消息前移                Array.Copy(_buffer, count + 4, _buffer, 0, _startIndex);            &#125;            else            &#123;                return;            &#125;        &#125;            &#125;&#125;\n\n\n\nProtobuf脚本：\n123456789101112131415161718192021222324252627282930313233// proto 版本syntax = &quot;proto3&quot;;// 命名空间package SocketGameProtocol;// 发起者enum RequestCode&#123;    RequestNone = 0;&#125;// 行为enum ActionCode&#123;    ActionNone = 0;&#125;// 返回的结果enum ReturnCode&#123;    ReturnNone = 0;&#125;// message在Protocol Buffers（protobuf）中用于定义一个消息类型。// 它类似于C#中的类或结构体，用于描述数据的结构。// 每个message包含一个或多个字段，每个字段都有一个唯一的编号，用于在序列化和反序列化过程中标识字段。message MainPack&#123;    RequestCode requestCode = 1;    ActionCode actionCode = 2;    ReturnCode returnCode = 3;    string message = 4;&#125;\n\n\n\n服务器框架：新建BaseController类来作为所有Controller的基类。\n123456789101112using SocketGameProtocol;namespace UnitySocketServer.Controller;public class BaseController&#123;        // 协议 发起行为的人的类型    protected RequestCode requestCode;    // 作为外部调用    public RequestCode RequestCode =&gt; requestCode;&#125;\n\n\n\n新建ControllerManager，用于管理与缓存所有的Controller\n123456789101112131415using SocketGameProtocol;namespace UnitySocketServer.Controller;public class ControllerManager&#123;    // 存储所有的Controller    private Dictionary&lt;RequestCode, BaseController&gt; _controllerDic = new Dictionary&lt;RequestCode, BaseController&gt;();    // 初始化所有的Controller    public ControllerManager()    &#123;            &#125;&#125;\n\n\n\n对于Protobuf脚本添加相应的操作码，行为码和状态码\n12345678910111213141516171819202122232425262728293031323334353637383940414243// proto 版本syntax = &quot;proto3&quot;;// 命名空间package SocketGameProtocol;// 请求的操作码enum RequestCode&#123;    RequestNone = 0;    // 用户    User = 1;&#125;// 请求的行为码enum ActionCode&#123;    ActionNone = 0;    // 注册    Register = 1;    // 登录    Login = 2;&#125;// 返回的状态码enum ReturnCode&#123;    ReturnNone = 0;    // 成功    Succeed = 1;    // 失败    Fail = 2;&#125;// message在Protocol Buffers（protobuf）中用于定义一个消息类型。// 它类似于C#中的类或结构体，用于描述数据的结构。// 每个message包含一个或多个字段，每个字段都有一个唯一的编号，用于在序列化和反序列化过程中标识字段。message MainPack&#123;    RequestCode requestCode = 1;    ActionCode actionCode = 2;    ReturnCode returnCode = 3;    string message = 4;&#125;\n\n\n\n新建UserController，用于管理用户的注册、登录等行为。\n1\n\n","slug":"Socket学习记录","date":"2023-11-07T12:41:10.000Z","categories_index":"","tags_index":"Unity网络开发","author_index":"sasigiii"},{"id":"7e125c2fcf5388ca1ef0a457d9c6ee91","title":"前缀和","content":"前缀和一维前缀和1.定义\n对于一维前缀和来说，前缀和是这个数组的某个下标之前的（包括当前下标对应的元素）所有元素之和。\n\n声明一个数组 a[]。\n\n数组 a[]的前缀和数组声明为 sum[]。\n根据前缀和数组定义可知每一项的值：\n123456sum[1]=a[1]sum[2]=a[1]+a[2]...sum[i]=a[1]+a[2]+...+a[i]...sum[n]=a[1]+a[2]+...+a[n]\n\n通过上述递推式我们可以得到：\n12sum[i−1]=a[1]+a[2]+a[3]+...+a[i−1]sum[i]=a[1]+a[2]+a[3]+...+a[i−1]+a[i]\n\n那么前缀和的递推式就可以写成：\n1sum[i]=sum[i−1]+a[i]\n\n2.前缀和的作用\n利用前缀和可以快速求得区间和。\n例如：\n数组a:存储元素\n\n\n\n元素\n1\n3\n6\n5\n4\n2\n\n\n\n下标\n1\n2\n3\n4\n5\n6\n\n\n数组sum: sum[i] &#x3D; sum[i-1] + a[i]\n\n\n\n元素\n1\n4\n10\n15\n19\n21\n\n\n\n下标\n1\n2\n3\n4\n5\n6\n\n\n有如下问题：\n对于数组a从第L个数加到第R个数得和是多少？累加区间为[L, R]。\n如果用for循环来写的话，时间复杂度为O(n)。\n12int s = 0;for(int i = L;i &lt;= R;i++) s = s + a[i];\n\n但是如果用前缀和来写的话，就可以把时间复杂度降为O(1)。\n123int s = 0;s = sum[R] - sum[L-1]；\n\n\n\n例如当 L&#x3D;2，R&#x3D;6时，s&#x3D;sum[6]−sum[1]&#x3D;20\n123456789101112131415161718192021222324252627282930#include&lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;  // 定义常量N，表示数组长度的上限int sum[N];  // 定义数组sum，用于存储前缀和int main() &#123;    int n, k, x;    cin &gt;&gt; n;  // 输入数组长度    // 计算前缀和    for(int i = 1; i &lt;= n; i++)     &#123;        cin &gt;&gt; x;  // 输入数组元素        sum[i] = sum[i - 1] + x;   // 计算前缀和并存储到数组sum中    &#125;    cin &gt;&gt; k;  // 输入查询次数k    while(k--)     &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;  // 输入查询区间[l,r]        // 输出区间和，利用前缀和数组sum进行快速计算        cout &lt;&lt; sum[r] - sum[l - 1] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n\n题目：1.一维前缀和题目描述对于一个有 n** 个元素的数组进行 kk 次区间求和。\n输入格式第一行：一个正整数 n； 第二行：n个正整数，表示数组中的 n个元素，每个整数不超过 10000，数值之间用一个空格分隔； 第三行：一个正整数 k，表示进行 k 次区间求和； 接下来 k行：每行两个整数 l和 r，表示计算第 l个数组元素到第 r个数组元素的和，包括第 l个和第 r个。\n输出格式共 k行，每行对应一次求和的结果。\n样例输入数据 1123456101 2 3 4 5 6 7 8 9 1031 31 56 10\n\n输出数据 112361540\n\n数据范围\n对于 100% 的数据，1≤l≤r≤n\n对于 50% 的数据，1≤n,k≤1000\n对于 100% 的数据，1≤n,k≤100000\n\n123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int n;    cin &gt;&gt; n;    int N = 1e5 + 10;    int sum[N];    sum[0] = 0;    for(int i = 0; i &lt; n; i++)    &#123;        int num;        cin &gt;&gt; num;        sum[i + 1] = sum[i] + num;    &#125;    int k;    cin &gt;&gt; k;    while(k--)    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        int res = sum[r] - sum[l - 1];        cout &lt;&lt; res &lt;&lt; endl;    &#125;    return 0;&#125;\n\n2.dash与机器人题目描述dash学长发明了一个机器人在数轴上运动，现在有 n 条移动指令需要机器人执行，分别为 a1,a2,…,an。 + 代表正向移动，− 代表反向移动，每条移动指令的规则如下：\n\n移动 a1的距离。\n\n移动 a1 的距离，再移动 a2 的距离。\n……\n\n移动 a1 的距离，再移动 a2 的距离，……，移动 an 的距离。\n\n\n请问最远能移动到数轴的正向位置。\n输入格式第一行为一个正整数 n，代表有 n条指令 。\n第二行为 n 个正整数 a1,a2,…,an，代表有 n 条指令。\n输出格式输出一行，一个整数表示答案。\n样例输入数据 1123-100 -1 -10\n\n输出数据 110\n\n解释 #1一直都在反向移动，最远的位置就是 0。\n输入数据 2124-1 2 1 -3\n\n输出数据 214\n\n解释 #2\n第一步移动到 −1 的位置。\n第二步先移动到 −2 的位置，再移动到 0 的位置。\n第三步先移动到 −1 的位置，再移动到 1 的位置，最后移动到 2 的位置。\n第四步先移动到 1 的位置，再移动到 3 的位置，再移动到 4 的位置，最后移动到 1 的位置。\n\n数据范围\n1≤N≤200000\n-108 ≤ Ai≤108\n\n这题的难点在于（1）机器人并不是移动完毕才是最大正向距离，而在移动途中也有可能到达最大正向距离。（2）数据范围需要使用long long。\n123456789101112131415161718192021222324252627282930313233343536#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int main()&#123;    int n;    cin &gt;&gt; n;        long long num[N];    long long sum[N];    long long maxi[N];    for(int i = 1;i &lt;= n;i++)    &#123;        cin &gt;&gt; num[i];        sum[i] = sum[i - 1] + num[i];        // 记录移动过程中的最大正向距离        maxi[i] = max(maxi[i - 1], sum[i]);    &#125;    long long curPos = 0;    long long maxPos = 0;    for(int i = 1; i &lt;= n; i++)    &#123;        maxPos = max(maxPos, maxi[i] + curPos);        curPos += sum[i];    &#125;    cout &lt;&lt; maxPos;    return 0;&#125;\n\n能简化为一个循环：\n1234567891011121314151617181920212223242526272829#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;int main()&#123;    int n;    cin &gt;&gt; n;        long long num;    long long sum[N];    long long curPos = 0;    long long maxPos = 0;    long long maxi = LLONG_MIN; // 初始化最大值为最小的 long long 值        for(int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; num;        sum[i] = sum[i - 1] + num;        maxi = max(maxi, sum[i]); // 维护最大值        maxPos = max(maxPos, maxi + curPos);        curPos += sum[i];    &#125;    cout &lt;&lt; maxPos;    return 0;&#125;\n\n\n\n3. 抓娃娃（编程题）题目描述小明拿了 n 条线段练习抓娃娃。他将所有线段铺在数轴上，第 i 条线段的左端点在  li，右端点在 ri。小明用 m个区间去框这些线段，第 i 个区间的范围是 Li，Ri。如果一个线段有 至少一半 的长度被包含在某个区间内，则将其视为被这个区间框住。请计算出每个区间框住了多少个线段？\n输入格式输入共 n+m+1行。\n第一行为两个正整数 n,m。\n后面 n行，每行两个整数 li，ri。\n后面 m行，每行两个整数 Li，Ri。\n输出格式输出共 m行，每行一个整数。\n样例输入数据 11234563 21 21 33 41 42 4\n\n输出数据 11232\n\n数据范围\n对于 20% 的数据，保证 n,m≤103。\n对于 100% 的数据，保证 n,m≤105，li &lt; ri，0 &lt; li，ri，Li，Ri &lt; 106，max{ri - li} ≤ min{Ri - Li} 。\n\n分析：根据数据范围max{ri - li} ≤ min{Ri - Li} 可知 区间包含在线段中的情况不可能存在。所以哪怕最长的线段长度也是小于区间的大小。可以将剩余三种情况列出来if - else if - else来分类计算。\n根据题目所说“如果一个线段有 至少一半 的长度被包含在某个区间内，则将其视为被这个区间框住”，我们可以得到一下的结论\n\n如果区间可以框住线段的话，一定包含这个线段的中点\n\n这样写能通过前两个测试点，后续的测试点超时。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;bits/stdc++.h&gt;using namespace std;// 计算一个区间框住了多少个线段int count( list&lt;int&gt; &amp;mid, pair&lt;int, int&gt; &amp;box)&#123;    int cnt = 0;    for(auto &amp; it : mid)    &#123;        if(it &gt;= box.first &amp;&amp; it &lt;= box.second)        &#123;            cnt++;        &#125;    &#125;    return cnt;&#125;int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    // 线段    list&lt;pair&lt;int, int&gt;&gt; line;    // 线段的中点    list&lt;int&gt; mid;    // 框线段的左右端点    list&lt;pair&lt;int, int&gt;&gt; box;    // 线段至少有一半被框框住，就视为被这个区间框住    // 说明这个线段如果被框住，那么他的中点一定在框里面    // 记录线段    for(int i = 0; i &lt; n; i++)    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        line.emplace_back(l, r);        mid.push_back((l + r) / 2);    &#125;    // 记录框线段    for(int i = 0; i &lt; m; i++)    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        box.emplace_back(l, r);        cout &lt;&lt; count(mid, box.back()) &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n\n优化：由于在for循环里每个循环都调用了count方法，使得时间复杂度变为了O(m * n)。要想压缩时间复杂度我们可以用一个数组来存储相同的中点个数。\n12345for (int i = 1;i &lt;= n;i++)&#123;    cin &gt;&gt; l &gt;&gt; r;    a[(l + r) / 2]++;//标记中点&#125;\n\n但是这样会带来一个问题：(l + r) &#x2F; 2 的值可能是小数，而小数是不能作数组的下标的。我们可以利用乘法将中点先乘 2，这样可以巧妙避免小数带来的影响。\n12345for (int i = 1;i &lt;= n;i++)&#123;    cin &gt;&gt; l &gt;&gt; r;    a[l + r]++;//标记中点&#125;\n\n\n\n处理好桶标记之后，我们需要求一个前缀和数组 s 记录范围内线段中点的数量，最后求一下 s[r]−s[l−1]也就是区间内有多少个线段中点即可。但由于之前中点乘以 2 的影响我们也需要将区间的左端点和有端点乘以 2 也就是 s[r∗2]−s[l∗2−1]。\n**TIPS:**将数组声明放在 main 函数外面可以大幅提升速度的原因是因为它们会被分配在全局&#x2F;静态内存区域，而不是栈内存中。全局&#x2F;静态内存区域的分配和访问速度通常比栈内存更快，尤其是当数组非常大时。\n在C++中，局部变量（如在 main 函数内声明的变量）通常分配在栈上，而全局变量或静态变量分配在全局&#x2F;静态内存区域。栈内存的大小是有限的，通常只有几MB，而全局&#x2F;静态内存区域的大小可以更大。  \n将数组声明放在 main 函数外面，可以避免栈溢出，并且全局&#x2F;静态内存区域的访问速度更快，从而提升程序的性能。\n1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;bits/stdc++.h&gt;using namespace std;// 在 2e6 + 10 中，e 代表科学计数法中的“指数”。它表示 (2 \\times 10^6)，即 2,000,000。加上 10 后的值是 2,000,010。const int N = 2e6 + 10;// 线段的中点int mid[N];// 前缀和数组int sum[N];int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    // 线段中点桶标记    for(int i = 0; i &lt; n; i++)    &#123;        int l, r;        cin &gt;&gt; l &gt;&gt; r;        mid[l + r]++;    &#125;    // 前缀和数组    for(int i = 1; i &lt;= 2e6; i++)    &#123;        // 表示从0到i一共有多少个中点        sum[i] = sum[i - 1] + mid[i];    &#125;    for(int i = 0; i &lt; m; i++)    &#123;        int L, R;        cin &gt;&gt; L &gt;&gt; R;        // 由于给中点做桶标记的时候是乘了2的，所以这里也要乘2        cout &lt;&lt; sum[2 * R] - sum[2 * L - 1] &lt;&lt; endl;    &#125;    return 0;&#125;\n\n\n\n4.加法的和题目描述有一天小D突发奇想，把十进制加法的定义重新改变，比如 f(114,514)&#x3D;114514。\n现在有 n个正整数，a1,a2,…,an，请问$$\\sum_{i&#x3D;1}^{n - 1} \\sum_{j&#x3D;i + 1}^{n} f(a_i, a_j) \\quad$$ 等于多少，最后的结果对 998244353998244353 取余。\n输入格式第一行为一个正整数 n，代表有 n个正整数。\n第二行为 n个正整数 a1,a2,…,an。\n输出格式输出一行，一个整数表示答案。\n样例输入数据 112311 14 9\n\n输出数据 111382\n\n解释 #1\nf(a1,a2)&#x3D;1114\nf(a1,a3)&#x3D;119\nf(a2,a3)&#x3D;149\n\nf(a1,a2)+f(a1,a3)+f(a2,a3)&#x3D;1382\n数据范围\n2≤N≤2×105\n1≤Ai≤109\n\n分析：\n1234567891011121314151617181920212223242526272829303132#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 10;const int mod = 998244353;long long int num[N], sum[N];int main()&#123;    int n;    cin &gt;&gt; n;    for(int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; num[i];        sum[i] = sum[i - 1] + num[i];    &#125;    long long res = 0;    for(int i = 2; i &lt;= n; i++)    &#123;        string temp = to_string(num[i]);        int len = temp.size();        long long mul = pow(10, len);        res = (res + ((sum[i - 1] % mod) * (mul % mod) % mod) + (i - 1) * num[i]) % mod;    &#125;    cout &lt;&lt; res &lt;&lt; endl;    return 0;&#125;\n\n\n\n5. 特殊质数小D发现了一种特殊的质数，满足如下两个条件可以称为一个特殊的质数：\n\nx 是一个奇数\nx和 (x+1)&#x2F;2都是质数\n\n现在有 q次询问，询问区间 [li,ri]之间有多少个特殊的质数\n输入格式第一行为一个正整数 q，代表有 q次询问。\n接下来 q行每行有两个正整数li和ri，表示区间 [li,ri]。\n输出格式输出一行，一个整数表示答案。\n样例输入数据 11213 7\n\n输出数据 112\n\n解释 #1\n3是奇数，同时 3和 (3+1)&#x2F;2&#x3D;2都是质数\n5是奇数，同时 5和 (5+1)&#x2F;2&#x3D;3都是质数\n\n输入数据 2123456761 5313 9137 5519 5173 9113 49\n\n\n\n输出数据 2123456441112\n\n数据范围\n1≤Q≤105\n1≤li&lt;≤ri≤105\nli和 ri都是奇数\n\n分析：暴力遍历区间，不出意外全部超时。其实这道题的数据范围比较小，最大也只有105,因此我们可以将1到10000的所有特殊质数预处理在前缀和数组里面。在由输入的l和r来调用前缀和数组的区间。\n暴力遍历：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;// 判断是不是奇数bool isOdd(int n)&#123;\tif(n % 2 != 0)\t&#123;\t\t// 是奇数\t\treturn true;\t&#125;\telse\t&#123;\t\treturn false;\t&#125;&#125;// 判断是不是质数 时间复杂度为nbool isPrime(int n)&#123;    if(n &lt;= 1)    &#123;        return false;    &#125;\tfor(int i = 2; i &lt;= sqrt(n); i++)\t&#123;\t\tif(n % i == 0)\t\t&#123;\t\t\treturn false;\t\t&#125;\t&#125;\treturn true;&#125;bool isSpecialPrime(int n)&#123;\t// x是奇数 x和（x+1）/2是质数 ，则这个数是特殊质数\tif(isOdd(n) &amp;&amp; isPrime(n) &amp;&amp; isPrime((n+1)/2))\t&#123;\t\treturn true;\t&#125;\telse\t&#123;\t\treturn false;\t&#125;&#125;int SpecialPrimeCount(int l, int r)&#123;\tint count = 0;\tfor(int i = l; i &lt;= r; i++)\t&#123;\t\tif(isSpecialPrime(i))\t\t&#123;\t\t\tcount++;\t\t&#125;\t&#125;\treturn count;&#125;int main()&#123;    int l, r, q;    cin &gt;&gt; q;    // 时间复杂度为n\tfor(int i = 0; i &lt; q; i++)\t&#123;\t\tcin &gt;&gt; l &gt;&gt; r;\t\tcout &lt;&lt; SpecialPrimeCount(l, r) &lt;&lt; endl;\t&#125;    return 0;&#125;\n\n\n\n前缀和：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;bits/stdc++.h&gt;using namespace std;bool isOdd(int n)&#123;    if(n % 2 != 0)    &#123;        // 閺勵垰顨岄弫?        return true;    &#125;    else    &#123;        return false;    &#125;&#125;bool isPrime(int n)&#123;    if (n &lt;= 1)    &#123;        return false;    &#125;    for(int i = 2; i &lt;= sqrt(n); i++)    &#123;        if(n % i == 0)        &#123;            return false;        &#125;    &#125;    return true;&#125;int IsSpecialPrime(int n)&#123;    if(isOdd(n) &amp;&amp; isPrime(n) &amp;&amp; isPrime((n+1)/2))    &#123;        return 1;    &#125;    else    &#123;        return 0;    &#125;&#125;int SpecialPrimeCount(int l, int r)&#123;    int count = 0;    for(int i = l; i &lt;= r; i++)    &#123;        if(IsSpecialPrime(i))        &#123;            count++;        &#125;    &#125;    return count;&#125;int specialPrimeSum[100010];// 构建前缀和数组void Init()&#123;    specialPrimeSum[0] = 0;    for(int i = 1; i &lt;= 100000; i++)    &#123;        if(IsSpecialPrime(i))        &#123;            specialPrimeSum[i] = specialPrimeSum[i - 1] + IsSpecialPrime(i);        &#125;    &#125;&#125;int main()&#123;    int l, r, q;    cin &gt;&gt; q;    for(int i = 1; i &lt;= 100000; i++) &#123;        specialPrimeSum[i] = specialPrimeSum[i - 1] + IsSpecialPrime(i);    &#125;\tfor(int i = 0; i &lt; q; i++)\t&#123;\t\tcin &gt;&gt; l &gt;&gt; r;\t\tcout &lt;&lt; specialPrimeSum[r] - specialPrimeSum[l - 1] &lt;&lt; endl;\t&#125;    return 0;&#125;\n\n","slug":"前缀和","date":"2023-11-07T12:41:10.000Z","categories_index":"","tags_index":"算法学习","author_index":"sasigiii"},{"id":"6b1fbd4218c627ebe69e7d6fff287d2a","title":"Unity中寻路方法的客户端和服务端使用","content":"AStar寻路:前言：在Unity3D中有一个内置的寻路解决方案：NavMeshes和NavMesh Agents。NavMeshes被用在可以行走的几何图形表面上，NavMesh Agents则挂载到游戏角色和其他需要导航的角色上。Navmeshes和NavMesh Agents一起工作来提供高效的寻路操作，有趣的是这个三维寻路解决方案的背后算法正是AStar。遗憾的是，在Unity2D中，并没有内置寻路的解决方案，我们必须手写相关的逻辑。\nAStar的工作原理：使用AStar的前提是：地图需要有一个网状结构。无论是用四叉树或八叉树做空间划分还是游戏地图本身就由Tilemap搭建。\n每个网格方块或节点根据从 start 节点到finish 节点都有一个“总成本”。每一个被评估过的节点都有一条回到start节点的路径，而这一路径是通过记录每个节点的父节点。因此通过记录每个节点的父节点我们可以得到一条回溯到起点的路径。\nAStar算法计算了几种成本：H成本，G成本和F成本。\nG成本：节点的G成本是指从起始节点到当前节点的路径总距离。值得注意的是，如果算法找到通往该节点的更短路径，节点的G成本可以被“改进”。\nH成本:  节点的H成本是指到终点的最小距离的一种简单计算。例如，如果方格之间的水平距离为10单位，而终点距离当前方格有3个水平方格，那么H成本将是30。需要注意的是，这只是最小距离，如果途中有障碍物，这条路径可能无法通行。对于一个节点而言，H成本是不会改变的。\nF成本： 节点的F成本是指节点的总成本，即是G成本和H成本的总和。算法通过评估节点，并选择从起点到终点具有最低FCost的路径来确定最短路径。\n该算法维护了“Open列表”和“Close列表”。从起始方格开始，算法将其周围所有方格添加到开放列表中。然后，从开放列表中选择F成本最低的方格，将其添加到关闭列表，并对其所有邻居重复此评估过程。此过程持续进行，直到到达目标节点并找到最短路径为止。\n值得考虑的是，只需要考虑网格中方格之间的距离(欧几里得距离)：\n\n现在我们已经大概了解了AStar的工作原理，接下来我们来看一段伪代码深入理解一下：\n\n首先我们创建一个Open表（存放将要进行评估的节点）和一个Close表（存放已经评估过的节点）。设置Start（起始节点），和Target（目标节点）。\n在算法一开始，我们将Start添加进Open表，在一个While循环（条件为“Open表里还有节点”）里，检索F成本最小的节点作为Current Node。如果正好有两个F成本一样小的节点，我们就选择H成本较小的那一个。在While循环开始时，我们将Start设置为Current Node。如果Current Node为Target我们就找到了路径，可以跳出循环，否则我们就将Current Node从Open表移到Close表中。对于Current Node我们会进入另一个循环，这个循环会检查Current Node的8个邻居节点，如果一个邻居节点是一个障碍物或者在Close表里，我们就跳过这个节点，对于每一个没被跳过的邻居节点，我们会计算它的F成本。首先我们计算它的G成本：从Start到Current Node的路径，这个G成本是基于当前节点的父节点回溯回Start的路径，因此对于任意给定节点，取决于所采用的路径，它有不同的G成本，当我们评估不同的路径时节点的G成本可能上升，也可能下降。如果它下降了，那么它会成为一个更好的候选路径。计算H成本：当前节点到Target的最小距离。对于一个特定的结点，H成本不会改变，因为它始终是到Target的最小距离。计算F成本：G成本+H成本。 因此，如果我们目前正在评估的邻居节点，如果邻居节点不在开放列表中，或它虽然在开放列表中，但重新计算的F成本更低，那么我们要保存这个节点的G成本，H成本和F成本，并且我们还要将这个邻居节点的父节点设置为Current Node。如果这个邻居节点不在Open表里，那么我们就将它添加进Open表。 最后我们就能得到一个能回溯到Start的最短路径。\n第一次循环：\n左上角为G成本：当前节点到Start的距离。右下角为H成本：当前节点到Finish的最短距离。中间为F成本：G成本+H成本。\n\n第二次循环：由于F成本为50的节点F成本最小，因此将其设置为Current Node，并添加进Close表（变为红色）。计算其邻居节点的三个成本。将其邻居节点全部加入Open表，再次选出其中F成本最小的节点作为Current Node。\n\n第三次循环：值得注意的是，我们评估邻居节点不仅仅是那些被添加到Open表里的新节点，同时也包括那些不在Close表里的邻居节点。\n\n第四次循环：一般在我们逐渐靠近终点的时候，对于F成本最低的节点来说，它的G成本会逐渐增加而H成本会逐渐减少（越来越靠近终点）。\n\n对于有障碍物的情况来说：图二中F成本为44的节点将被选中，同时F成本为66的邻居节点的G成本将得到更新。图三中有两个节点F成本一致，我们要选择H成本较小的那个。最后通过父节点的关系回溯找到最短路径。\n\n\n对于Open表和Close表的数据结构的选择：Open表：我们将使用C#中的List&lt;T&gt; ，因为我们需要对集合进行排序从而找出F成本最小的那个节点。\nClose表：我们将使用 C# 的泛型集合 HashSet&lt;T&gt;。其中的 T 表示网格方格节点。Close表不需要进行排序，只需检查某个节点是否已经存在于Close表中。HashSet 的 Contains 方法可以完成此操作，并且速度非常快，因为它不需要逐一遍历每个元素，而是通过计算的哈希值直接进行检查。\n","slug":"Unity中寻路方法的客户端和服务端使用","date":"2023-11-07T12:41:10.000Z","categories_index":"","tags_index":"Unity开发","author_index":"sasigiii"},{"id":"48226afb8ff83ee8121572321054a22a","title":"Unity网络开发基础","content":"网络基本概念\n网络：由若干设备和连接这些设备的链路构成，设备间可以相互通信。\n\n局域网：指某一个小区域内由多台设备互联成的计算机组。\n\n以太网：网络连接的一种规则，定义了连接传输规范。\n\n域域网：是在一个城市范围内所建立的网络，几十到一百公里。\n\n广域网：是连接不同地区，城市，国家的远处网络，几十到几千公里。\n\n互联网（因特网）：是目前国际上最大的互联网，定义了通信规则等。\n\n万维网（WWW）: 是基于因特网的网站和网页的统称。\n练习题\n常见的网络拓扑结构有哪些？（请至少写出5种拓扑结构）\n1答案：网状拓扑结构，总线型拓扑结构，树形拓扑结构，环状拓扑结构，星形拓扑结构。\n\n\n\n网络是如何让设备之间可以通信的？\n12网络通信是通过物理连接（如网线或无线连接）和中间设备（如交换机、路由器）来实现设备之间的通信。设备间想要传输信息时，将想要传递的数据编码为二进制数值便可以有效的传输。这些数据是以电脉冲的形式进行传输的。线缆中的电压是在高低状态之间进行变化的，因而二进制中的1是通过产生一个正电压来传输的，二进制中的0是通过产生一个负电压来传输的。\n\n\n\n","slug":"Unity网络开发基础","date":"2023-11-07T12:41:10.000Z","categories_index":"","tags_index":"Unity网络开发","author_index":"sasigiii"}]